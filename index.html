<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Conjunctival Eye ROI • Ellipse + rPPG (iPhone Safari)</title>
<style>
  :root{--fg:#e8f0ff;--bg:#0b1220;--mut:#a8b4d9;--ok:#95f395;--warn:#ffd27d;--bad:#ff7d7d;--card:rgba(255,255,255,.06);--line:rgba(255,255,255,.12)}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
  h2{margin:.2rem 0 .4rem}
  .wrap{padding:10px 10px calc(76px + env(safe-area-inset-bottom));max-width:980px;margin:0 auto;display:flex;flex-direction:column;gap:10px}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:10px}
  @media (max-width:800px){.grid{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:10px}
  .row{display:flex;flex-wrap:wrap;gap:10px}
  .metric{flex:1 1 30%;min-width:120px}
  .metric h4{margin:.1rem 0;color:var(--mut);font-size:12px}
  .metric .val{font-size:16px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .hint{font-size:12px;color:var(--mut)}
  /* Preview stack: canvas scales responsively with preserved aspect (height auto) */
  .stack{position:relative}
  #video{display:none}
  #overlay{width:100%;height:auto;display:block;border-radius:12px;background:#000;max-height:360px}
  .plot{height:110px;background:rgba(0,0,0,.3);border-radius:8px;width:100%}
  .rail{position:sticky;top:8px;display:flex;flex-direction:column;gap:10px}
  .rail h3{margin:.2rem 0 .4rem;font-size:14px;color:var(--mut)}
  .thumb{width:100%;height:auto;border-radius:10px;background:#000;display:block}
  /* Bottom dock (always reachable) */
  .dock{position:fixed;left:0;right:0;bottom:0;padding:8px 10px calc(8px + env(safe-area-inset-bottom));background:rgba(10,14,26,.9);backdrop-filter:blur(10px);border-top:1px solid var(--line);display:flex;gap:8px;align-items:center;justify-content:space-between;z-index:50}
  .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);font-size:12px;display:flex;gap:8px;align-items:center}
  .btn{background:#2a3656;border:1px solid #3b4a74;color:var(--fg);padding:10px 12px;border-radius:12px;font-weight:600}
  .btn[disabled]{opacity:.5}
  #recStatus{font-size:12px}
  #debug{font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <h2>Conjunctival Eye ROI • Ellipse</h2>
  <div class="hint">Safari on iPhone, HTTPS (GitHub Pages). Use **Selfie** for one eye; controls are fixed at the bottom.</div>

  <div class="grid">
    <div>
      <div class="stack">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>Focus (VarLap)</h4><div id="mFocus" class="val">—</div></div>
          <div class="metric"><h4>Motion MAD</h4><div id="mMotion" class="val">—</div></div>
          <div class="metric"><h4>Glare %</h4><div id="mGlare" class="val">—</div></div>
          <div class="metric"><h4>ROI coverage</h4><div id="mRoi" class="val">—</div></div>
          <div class="metric"><h4>Status</h4><div id="mStatus" class="val">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>Pallor: mean R</h4><div id="pR" class="val">—</div></div>
          <div class="metric"><h4>Pallor: mean G</h4><div id="pG" class="val">—</div></div>
          <div class="metric"><h4>Pallor: mean B</h4><div id="pB" class="val">—</div></div>
          <div class="metric"><h4>Pallor: R/G</h4><div id="pRG" class="val">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>rPPG HR (BPM)</h4><div id="rHR" class="val">—</div></div>
          <div class="metric"><h4>rPPG AC/DC</h4><div id="rACDC" class="val">—</div></div>
          <div class="metric"><h4>rPPG SNR</h4><div id="rSNR" class="val">—</div></div>
        </div>
        <canvas id="plot" class="plot"></canvas>
      </div>

      <div class="card">
        <b>Debug:</b> <span id="debug" class="hint">Ready.</span>
      </div>
    </div>

    <div class="rail">
      <div class="card">
        <h3>Aiming crop (live, no stretch)</h3>
        <canvas id="aimView" width="320" height="220" class="thumb"></canvas>
      </div>
      <div class="card">
        <div class="row">
          <div class="metric"><h4>ROI View (10-s)</h4></div>
          <div class="metric"><h4>Vesselness (10-s avg)</h4></div>
        </div>
        <div class="row">
          <canvas id="roiView" width="240" height="160" class="thumb"></canvas>
          <canvas id="vesselView" width="240" height="160" class="thumb"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Bottom dock controls -->
<div class="dock">
  <div class="pill">
    <span>Camera:</span>
    <label><input type="radio" name="cam" value="environment"> Rear</label>
    <label><input type="radio" name="cam" value="user" checked> Selfie</label>
    <span id="recStatus">Idle</span>
  </div>
  <div style="display:flex;gap:8px">
    <button class="btn" id="btnStart">Start Camera</button>
    <button class="btn" id="btnStop">Stop</button>
    <button class="btn" id="btnRecord">Record 10s → Analyze</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>
<script>
/* Elements */
const video=document.getElementById('video');
const overlay=document.getElementById('overlay'); const ctx=overlay.getContext('2d');
const aimCanvas=document.getElementById('aimView'); const aimCtx=aimCanvas.getContext('2d');
const roiCanvas=document.getElementById('roiView'); const roiCtx=roiCanvas.getContext('2d');
const vesselCanvas=document.getElementById('vesselView'); const vesselCtx=vesselCanvas.getContext('2d');
const plot=document.getElementById('plot'); const pctx=plot.getContext('2d');
const dbg=document.getElementById('debug');
const ui={
  focus: mFocus, motion: mMotion, glare: mGlare, roi: mRoi, status: mStatus,
  pR, pG, pB, pRG, rHR, rACDC, rSNR,
  btnStart: btnStart, btnStop: btnStop, btnRecord: btnRecord, recStatus: recStatus
};

/* State */
let running=false, faceMesh, faceMeshReady=false, roiPoly=null;
let lastGraySmall=null, greenSeries=[], sampleTimes=[];
let vesselSum=null, vesselCount=0, recording=false, recordStart=0, recTimer=null;
const MAX_SERIES=600;
const TH={minVarLap:80,maxMotion:0.08,maxGlare:0.10,minRoiFrac:0.02};

/* Helpers */
function logDebug(m,e=false){ dbg.textContent=m; dbg.className=e?'bad':'hint'; }
function selectedFacingMode(){ const r=[...document.querySelectorAll('input[name="cam"]')].find(x=>x.checked); return r? r.value:"environment"; }
function setClass(el, ok){ el.className='val '+(ok?'ok':'warn'); }
function resizeToVideo(){
  overlay.width=video.videoWidth||1280; overlay.height=video.videoHeight||720;
  plot.width=Math.min(overlay.width,900); plot.height=110;
}
function toGraySmall(imageData,w,h,outW=160,outH=120){
  const gray=new Uint8ClampedArray(outW*outH), d=imageData.data;
  for(let j=0;j<outH;j++){ const y=Math.floor(j*h/outH);
    for(let i=0;i<outW;i++){ const x=Math.floor(i*w/outW); const idx=(y*w+x)*4;
      gray[j*outW+i]=(0.299*d[idx]+0.587*d[idx+1]+0.114*d[idx+2]);
    }
  } return {gray,outW,outH};
}
function varianceOfLaplacian(gray,w,h){
  const k=[0,1,0,1,-4,1,0,1,0]; let s=0,ss=0,n=0;
  for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
    let c=0,ki=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) c+=gray[(y+dy)*w+(x+dx)]*k[ki++];
    s+=c; ss+=c*c; n++;
  }
  if(n<2) return 0; const m=s/n; return ss/n - m*m;
}
function normalizedMADDiff(prev,curr){ let sa=0, sc=0, n=curr.length; for(let i=0;i<n;i++){ sa+=Math.abs(curr[i]-prev[i]); sc+=curr[i]; } const mi=Math.max(1,sc/n); return (sa/n)/mi; }
function glareFraction(imageData, poly){
  const {width:w,height:h,data}=imageData, bb=polyBBox(poly);
  let cnt=0, br=0; const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(w-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(h-1,Math.ceil(bb.maxY));
  for(let y=minY;y<=maxY;y++) for(let x=minX;x<=maxX;x++){
    if(!pointInPoly(x,y,poly)) continue; const idx=(y*w+x)*4;
    const Y=0.299*data[idx]+0.587*data[idx+1]+0.114*data[idx+2]; cnt++; if(Y>=245) br++;
  }
  return cnt? br/cnt : 1.0;
}
function meanRGB(imageData, poly){
  const {width:w,height:h,data}=imageData, bb=polyBBox(poly);
  let sr=0,sg=0,sb=0,n=0; const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(w-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(h-1,Math.ceil(bb.maxY));
  for(let y=minY;y<=maxY;y++) for(let x=minX;x<=maxX;x++){
    if(!pointInPoly(x,y,poly)) continue; const idx=(y*w+x)*4; sr+=data[idx]; sg+=data[idx+1]; sb+=data[idx+2]; n++;
  }
  return n? {r:sr/n,g:sg/n,b:sb/n,n} : {r:0,g:0,b:0,n:0};
}
function polyBBox(poly){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; for(const p of poly){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
function pointInPoly(x,y,poly){ let inside=false; for(let i=0,j=poly.length-1;i<poly.length;j=i++){ const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y; const inter=((yi>y)!=(yj>y))&&(x< (xj-xi)*(y-yi)/(yj-yi)+xi); if(inter) inside=!inside; } return inside; }
function drawPolyFilled(poly, stroke='rgba(255,255,0,0.95)', fill='rgba(255,255,0,0.15)'){
  if(!poly||!poly.length) return; ctx.save(); ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(poly[0].x,poly[0].y); for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x,poly[i].y);
  ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
}
/* PCA-based ellipse fit to eye landmarks (single eye) */
function fitEyeEllipse(lm, W, H, right=true, scale=1.0){
  // Full right eye contour (MediaPipe indices); left counterpart below
  const eyeR=[33,7,163,144,145,153,154,155,133,173,157,158,159,160,161,246];
  const eyeL=[263,249,390,373,374,380,381,382,362,398,384,385,386,387,388,466];
  const ids = right? eyeR : eyeL;
  const pts = ids.map(i=>({x:lm[i].x*W, y:lm[i].y*H}));
  // mean
  let cx=0, cy=0; for(const p of pts){ cx+=p.x; cy+=p.y; } cx/=pts.length; cy/=pts.length;
  // covariance
  let sxx=0, syy=0, sxy=0; for(const p of pts){ const dx=p.x-cx, dy=p.y-cy; sxx+=dx*dx; syy+=dy*dy; sxy+=dx*dy; }
  sxx/=pts.length; syy/=pts.length; sxy/=pts.length;
  // eigen (2x2)
  const T=sxx+syy, D=sxx*syy - sxy*sxy;
  const disc=Math.max(0, T*T/4 - D);
  const l1=T/2 + Math.sqrt(disc), l2=T/2 - Math.sqrt(disc);
  // principal axes (eigenvectors)
  let vx1,vy1,vx2,vy2;
  if(Math.abs(sxy)>1e-6){ vx1=l1-syy; vy1=sxy; const n1=Math.hypot(vx1,vy1)||1; vx1/=n1; vy1/=n1; vx2=-vy1; vy2=vx1; }
  else { vx1=1; vy1=0; vx2=0; vy2=1; }
  // radii = max projection of points onto each axis (scaled)
  let a=0,b=0;
  for(const p of pts){
    const dx=p.x-cx, dy=p.y-cy;
    const t1=Math.abs(dx*vx1 + dy*vy1); if(t1>a) a=t1;
    const t2=Math.abs(dx*vx2 + dy*vy2); if(t2>b) b=t2;
  }
  a*=scale; b*=scale;
  // polygon approximation of rotated ellipse
  const poly=[]; const N=64;
  for(let k=0;k<N;k++){
    const th=2*Math.PI*k/N;
    const ex=a*Math.cos(th), ey=b*Math.sin(th);
    const x=cx + ex*vx1 + ey*vx2;
    const y=cy + ex*vy1 + ey*vy2;
    poly.push({x,y});
  }
  return {poly,center:{x:cx,y:cy},axes:{a,b},vecs:{vx1,vy1,vx2,vy2}};
}
/* Fallback band */
function fallbackRoi(W,H){ const y0=H*0.45,y1=y0+Math.max(8,H*0.03),x0=W*0.30,x1=W*0.70; return [{x:x0,y:y0},{x:x1,y:y0},{x:x1,y:y1},{x:x0,y:y1}]; }
/* Box blur */
function boxBlur(gray,w,h,r=3){ const tmp=new Float32Array(w*h), out=new Float32Array(w*h);
  for(let y=0;y<h;y++){ let sum=0; for(let x=0;x<w;x++){ const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
    if(x===0){ sum=0; for(let i=x0;i<=x1;i++) sum+=gray[y*w+i]; } else { const prev=Math.max(0,x-1-r), next=Math.min(w-1,x+r); sum += gray[y*w+next]-gray[y*w+prev]; }
    tmp[y*w+x]=sum/(x1-x0+1); } }
  for(let x=0;x<w;x++){ let sum=0; for(let y=0;y<h;y++){ const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    if(y===0){ sum=0; for(let j=y0;j<=y1;j++) sum+=tmp[j*w+x]; } else { const prev=Math.max(0,y-1-r), next=Math.min(h-1,y+r); sum += tmp[next*w+x]-tmp[prev*w+x]; }
    out[y*w+x]=sum/(y1-y0+1); } } return out;
}
/* Conjunctiva-ish mask inside ROI (drop sclera glare, lashes, too-dark/too-bright) */
function conjunctivaMask(imageData, roiPoly){
  const {width:W,height:H,data}=imageData, bb=polyBBox(roiPoly);
  const x0=Math.max(0,Math.floor(bb.minX)), x1=Math.min(W-1,Math.ceil(bb.maxX));
  const y0=Math.max(0,Math.floor(bb.minY)), y1=Math.min(H-1,Math.ceil(bb.maxY));
  const outW=x1-x0+1, outH=y1-y0+1, mask=new Uint8Array(outW*outH);
  for(let y=y0;y<=y1;y++) for(let x=x0;x<=x1;x++){
    if(!pointInPoly(x,y,roiPoly)) continue;
    const idx=(y*W+x)*4, r=data[idx], g=data[idx+1], b=data[idx+2];
    const V=Math.max(r,g,b), S= V? (V - Math.min(r,g,b))/V : 0;
    const isSclera=(V>240 && S<0.12), isLash=(V<35);
    const looksConj=(!isSclera && !isLash && r>=g && g>=b && S>=0.10 && S<=0.65 && V>=50 && V<=230);
    mask[(y-y0)*outW+(x-x0)] = looksConj?1:0;
  }
  return {mask,x0,y0,w:outW,h:outH};
}
function extractGreenConj(imageData, roiPoly, outW=240, outH=160){
  const {width:W,height:H,data}=imageData, bb=polyBBox(roiPoly);
  const x0=Math.max(0,Math.floor(bb.minX)), x1=Math.min(W-1,Math.ceil(bb.maxX));
  const y0=Math.max(0,Math.floor(bb.minY)), y1=Math.min(H-1,Math.ceil(bb.maxY));
  const roiW=x1-x0+1, roiH=y1-y0+1;
  const m = conjunctivaMask(imageData, roiPoly);
  const g=new Float32Array(outW*outH), mask=new Uint8Array(outW*outH);
  for(let j=0;j<outH;j++){ const sy=y0 + Math.floor(j*roiH/outH);
    for(let i=0;i<outW;i++){ const sx=x0 + Math.floor(i*roiW/outW); const idx=(sy*W+sx)*4;
      const mVal=(sx>=m.x0 && sx<m.x0+m.w && sy>=m.y0 && sy<m.y0+m.h) ? m.mask[(sy-m.y0)*m.w + (sx-m.x0)] : 0;
      mask[j*outW+i]=mVal?1:0; g[j*outW+i]=mVal? data[idx+1] : 0;
    }
  }
  return {g,w:outW,h:outH,mask,bb:{x0,y0,x1,y1}};
}
function vesselnessTopHatMasked(g,w,h,mask,blurR=3){
  const blurred=boxBlur(g,w,h,blurR); const raw=new Float32Array(w*h); let maxv=1e-6;
  for(let i=0;i<w*h;i++){ const v=mask[i]? Math.max(0, g[i]-blurred[i]) : 0; raw[i]=v; if(v>maxv) maxv=v; }
  const out=new Uint8ClampedArray(w*h); for(let i=0;i<w*h;i++) out[i]=Math.round(255*(raw[i]/maxv)); return out;
}
/* rPPG plotting + analysis */
function plotSeries(series){
  const w=plot.width,h=plot.height; pctx.clearRect(0,0,w,h);
  if(series.length<2) return;
  const maxV=Math.max(...series), minV=Math.min(...series), rng=Math.max(1e-3,maxV-minV);
  pctx.strokeStyle="#7ef5d6"; pctx.lineWidth=2; pctx.beginPath();
  for(let i=0;i<series.length;i++){ const x=i*(w/(series.length-1)); const y=h-((series[i]-minV)/rng)*h; if(i===0) pctx.moveTo(x,y); else pctx.lineTo(x,y); }
  pctx.stroke();
}
function detrend(a,win=21){ const o=new Array(a.length).fill(0); for(let i=0;i<a.length;i++){ const A=Math.max(0,i-Math.floor(win/2)), B=Math.min(a.length-1,i+Math.floor(win/2)); let s=0; for(let k=A;k<=B;k++) s+=a[k]; o[i]=a[i]-s/(B-A+1);} return o; }
function hamming(N){ const w=new Array(N); for(let n=0;n<N;n++) w[n]=0.54-0.46*Math.cos(2*Math.PI*n/(N-1)); return w; }
function periodogramDFT(x,fs,freqs){ const N=x.length,P=new Array(freqs.length).fill(0); for(let k=0;k<freqs.length;k++){ const w=2*Math.PI*freqs[k]/fs; let re=0,im=0; for(let n=0;n<N;n++){ const ph=w*n; re+=x[n]*Math.cos(ph); im-=x[n]*Math.sin(ph);} P[k]=(re*re+im*im)/N;} return P; }
function analyzeRppg(times, vals){
  if(times.length<50) return {hr:null,acdc:null,snr:null};
  const dur=Math.max(0.1,times[times.length-1]-times[0]), fs=25;
  const M=Math.max(64,Math.min(256,Math.round(dur*fs))), t0=times[0], dt=dur/(M-1), xs=new Array(M);
  for(let i=0;i<M;i++){ const t=t0+i*dt; let j=0; while(j<times.length-1 && times[j]<t) j++; xs[i]=vals[Math.max(0,Math.min(times.length-1,j))]; }
  let x=detrend(xs,Math.round(fs*0.8)); const win=hamming(x.length); for(let i=0;i<x.length;i++) x[i]*=win[i];
  const mean=xs.reduce((a,b)=>a+b,0)/xs.length; const sd=Math.sqrt(x.reduce((a,b)=>a+b*b,0)/x.length);
  const acdc=mean>0? (sd/mean) : null;
  const fmin=0.8,fmax=3.5,step=0.02,freqs=[]; for(let f=fmin;f<=fmax;f+=step) freqs.push(f);
  const P=periodogramDFT(x,fs,freqs); let iMax=0; for(let i=1;i<P.length;i++) if(P[i]>P[iMax]) iMax=i;
  const fPeak=freqs[iMax], hr=Math.round(fPeak*60);
  const side=[]; for(let i=0;i<P.length;i++){ if(Math.abs(freqs[i]-fPeak)>0.06 && Math.abs(freqs[i]-fPeak)<0.5) side.push(P[i]); }
  const median= side.length? side.slice().sort((a,b)=>a-b)[Math.floor(side.length/2)] : 1e-6;
  const snr=(P[iMax]/Math.max(1e-6,median)).toFixed(2);
  return {hr, acdc: acdc? acdc.toFixed(4):null, snr};
}

/* MediaPipe */
async function initFaceMesh(){
  faceMesh=new FaceMesh.FaceMesh({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
  faceMesh.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
  faceMesh.onResults(onResults); faceMeshReady=true; logDebug('FaceMesh initialized.');
}

/* Camera */
async function startCamera(){
  try{
    const mode=selectedFacingMode();
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:mode},width:{ideal:1280},height:{ideal:720}},audio:false});
    video.srcObject=stream;
    await new Promise(res=> video.onloadedmetadata=()=>{ video.play(); resizeToVideo(); res(); });
  }catch(e){ logDebug('Camera error: '+e.message,true); throw e; }
}
function stopCamera(){ const s=video.srcObject; if(s) s.getTracks().forEach(t=>t.stop()); video.srcObject=null; }

/* ROI builders */
function buildEyeEllipse(lm,W,H,right=true){
  const {poly}=fitEyeEllipse(lm,W,H,right,1.15); // 15% pad to cover palpebral conjunctiva
  return poly;
}

/* Frame processing */
function onResults(res){
  if(!running) return;
  ctx.save();
  if(selectedFacingMode()==="user"){ ctx.translate(overlay.width,0); ctx.scale(-1,1); } // mirror selfie
  ctx.drawImage(res.image,0,0,overlay.width,overlay.height);
  roiPoly=null;
  if(res.multiFaceLandmarks && res.multiFaceLandmarks.length>0){
    roiPoly=buildEyeEllipse(res.multiFaceLandmarks[0], overlay.width, overlay.height, true); // single RIGHT eye
    drawPolyFilled(roiPoly);
  }else{
    roiPoly=fallbackRoi(overlay.width,overlay.height);
    drawPolyFilled(roiPoly,'rgba(0,200,255,0.95)','rgba(0,200,255,0.18)');
  }
  ctx.restore();
  computeMetricsAndUpdateUI();
}

function computeMetricsAndUpdateUI(){
  const frame=ctx.getImageData(0,0,overlay.width,overlay.height);
  const {gray,outW,outH}=toGraySmall(frame,overlay.width,overlay.height);
  const varLap=varianceOfLaplacian(gray,outW,outH);
  const motion=lastGraySmall? normalizedMADDiff(lastGraySmall,gray):0; lastGraySmall=gray;

  let glare=1.0, rgb={r:0,g:0,b:0,n:0}, roiFrac=0;
  if(roiPoly){
    glare=glareFraction(frame,roiPoly);
    rgb=meanRGB(frame,roiPoly);
    const bb=polyBBox(roiPoly); roiFrac=((bb.maxX-bb.minX)*(bb.maxY-bb.minY))/(overlay.width*overlay.height);
  }

  if(rgb.n>0){ ui.pR.textContent=rgb.r.toFixed(0); ui.pG.textContent=rgb.g.toFixed(0); ui.pB.textContent=rgb.b.toFixed(0); ui.pRG.textContent= (rgb.g>0?(rgb.r/rgb.g).toFixed(3):"—"); }

  const focusOk=varLap>=TH.minVarLap, motionOk=motion<=TH.maxMotion||!lastGraySmall, glareOk=glare<=TH.maxGlare, roiOk=roiFrac>=TH.minRoiFrac;
  const pass=focusOk&&motionOk&&glareOk&&roiOk;
  ui.focus.textContent=varLap.toFixed(0); setClass(ui.focus,focusOk);
  ui.motion.textContent=motion.toFixed(3); setClass(ui.motion,motionOk);
  ui.glare.textContent=(glare*100).toFixed(1)+"%"; setClass(ui.glare,glareOk);
  ui.roi.textContent=(roiFrac*100).toFixed(2)+"%"; setClass(ui.roi,roiOk);
  ui.status.textContent= pass ? "PASS" : "Adjust aim / light / stability"; setClass(ui.status,pass);

  const now=performance.now()/1000;
  if(rgb.n>0){ greenSeries.push(rgb.g); sampleTimes.push(now);
    if(greenSeries.length>MAX_SERIES){ greenSeries.splice(0,greenSeries.length-MAX_SERIES); sampleTimes.splice(0,sampleTimes.length-MAX_SERIES); }
    plotSeries(greenSeries);
  }

  // Aiming crop (no aspect distortion): draw a padded bbox around ellipse using "contain"
  if(roiPoly){
    const bb=polyBBox(roiPoly);
    const padX=Math.max(8,(bb.maxX-bb.minX)*0.35), padY=Math.max(8,(bb.maxY-bb.minY)*0.8);
    const sx=Math.max(0,Math.floor(bb.minX-padX)), sy=Math.max(0,Math.floor(bb.minY-padY));
    const sw=Math.min(overlay.width-1,Math.ceil(bb.maxX+padX))-sx+1;
    const sh=Math.min(overlay.height-1,Math.ceil(bb.maxY+padY))-sy+1;
    // compute scale to contain into aimCanvas
    const S=Math.min(aimCanvas.width/sw, aimCanvas.height/sh);
    const dw=sw*S, dh=sh*S; const dx=(aimCanvas.width-dw)/2, dy=(aimCanvas.height-dh)/2;
    aimCtx.save(); aimCtx.clearRect(0,0,aimCanvas.width,aimCanvas.height);
    if(selectedFacingMode()==="user"){ aimCtx.translate(aimCanvas.width,0); aimCtx.scale(-1,1); }
    aimCtx.drawImage(overlay, sx,sy,sw,sh, dx,dy,dw,dh);
    aimCtx.restore();
  }
}

/* Loop */
async function loop(){
  if(!running) return;
  try{
    if(faceMeshReady){ await faceMesh.send({image:video}); }
    else{
      ctx.drawImage(video,0,0,overlay.width,overlay.height);
      roiPoly=fallbackRoi(overlay.width,overlay.height);
      drawPolyFilled(roiPoly,'rgba(0,200,255,0.95)','rgba(0,200,255,0.18)');
      computeMetricsAndUpdateUI();
    }
  }catch(e){ logDebug('Loop error: '+e.message,true); }
  requestAnimationFrame(loop);
}

/* Record / Analyze */
function startRecording(){
  if(!running||recording) return;
  recording=true; recordStart=performance.now()/1000; ui.btnRecord.disabled=true;
  vesselSum=null; vesselCount=0; roiCtx.clearRect(0,0,roiCanvas.width,roiCanvas.height); vesselCtx.clearRect(0,0,vesselCanvas.width,vesselCanvas.height);
  let left=10.0; ui.recStatus.textContent=`Recording: ${left.toFixed(1)}s`;
  recTimer=setInterval(()=>{ left=Math.max(0,10-(performance.now()/1000-recordStart)); ui.recStatus.textContent=`Recording: ${left.toFixed(1)}s`; if(left<=0) stopRecordingAndAnalyze(); },100);
}
function cancelCountdown(){ if(recTimer){ clearInterval(recTimer); recTimer=null; } }
function stopRecordingAndAnalyze(){
  cancelCountdown(); recording=false; ui.recStatus.textContent="Analyzing…";
  const now=sampleTimes.length? sampleTimes[sampleTimes.length-1]:0;
  const idx=sampleTimes.findIndex(t=>t>=now-10);
  const times= idx>=0? sampleTimes.slice(idx): sampleTimes.slice();
  const vals = idx>=0? greenSeries.slice(idx): greenSeries.slice();
  const res=analyzeRppg(times,vals);
  ui.rHR.textContent = res.hr? res.hr.toString():"—";
  ui.rACDC.textContent = res.acdc? res.acdc:"—";
  ui.rSNR.textContent = res.snr? res.snr:"—";

  if(roiPoly){
    const frame=ctx.getImageData(0,0,overlay.width,overlay.height);
    const crop=extractGreenConj(frame,roiPoly,roiCanvas.width,roiCanvas.height);
    const enh=vesselnessTopHatMasked(crop.g,crop.w,crop.h,crop.mask,3);
    // accumulate average (here single pass is fine)
    if(!vesselSum){ vesselSum=new Float32Array(enh.length); vesselCount=0; }
    for(let i=0;i<enh.length;i++) vesselSum[i]+=enh[i]; vesselCount++;

    const avg=new Uint8ClampedArray(vesselSum.length); let maxv=1e-6;
    for(let i=0;i<vesselSum.length;i++) if(vesselSum[i]>maxv) maxv=vesselSum[i];
    for(let i=0;i<avg.length;i++) avg[i]=Math.round(255*(vesselSum[i]/maxv));
    const vs=vesselCtx.createImageData(roiCanvas.width,roiCanvas.height);
    for(let i=0;i<avg.length;i++){ const v=avg[i]; vs.data[4*i+0]=v*0.6; vs.data[4*i+1]=v; vs.data[4*i+2]=v*0.8; vs.data[4*i+3]=255; }
    vesselCtx.putImageData(vs,0,0);

    const roiImg=roiCtx.createImageData(crop.w,crop.h);
    for(let i=0;i<crop.w*crop.h;i++){ const v=crop.mask[i]? Math.round(crop.g[i]):0; roiImg.data[4*i+0]=v; roiImg.data[4*i+1]=v; roiImg.data[4*i+2]=v; roiImg.data[4*i+3]=255; }
    roiCtx.putImageData(roiImg,0,0);
  }
  ui.recStatus.textContent="Done"; ui.btnRecord.disabled=false;
}

/* Controls */
async function start(){
  ui.btnRecord.disabled=true; logDebug('Starting camera…');
  await startCamera(); resizeToVideo();
  logDebug('Initializing FaceMesh…'); try{ await initFaceMesh(); }catch(e){ logDebug('FaceMesh init error: '+e.message,true); }
  running=true; ui.recStatus.textContent='Live'; ui.btnRecord.disabled=false; loop();
}
function stop(){ running=false; stopCamera(); cancelCountdown(); ui.recStatus.textContent='Idle'; logDebug('Stopped.'); }

btnStart.onclick=async()=>{ if(!running) await start(); };
btnStop.onclick =()=> stop();
btnRecord.onclick=()=> startRecording();

/* Guards */
window.addEventListener('error',e=>logDebug('JS error: '+e.message,true));
if(!('mediaDevices' in navigator)) logDebug('Error: mediaDevices not available (use Safari over HTTPS).',true);
</script>
</body>
</html>
