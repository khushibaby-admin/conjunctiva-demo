<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Conjunctival ROI • Pallor + rPPG Demo (iPhone Safari)</title>
<style>
  :root { --fg:#e8f0ff; --bg:#0b1220; --mut:#a8b4d9; --ok:#95f395; --warn:#ffd27d; --bad:#ff7d7d;}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{padding:12px;display:flex;flex-direction:column;gap:12px;max-width:720px;margin:0 auto}
  .stack{position:relative}
  video,canvas{width:100%;border-radius:12px;background:#000}
  .card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px}
  .row{display:flex;flex-wrap:wrap;gap:10px}
  .metric{flex:1 1 30%;min-width:120px}
  .metric h4{margin:.1rem 0;color:var(--mut);font-size:12px}
  .metric .val{font-size:16px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .plot{height:120px;background:rgba(0,0,0,.3);border-radius:8px}
  .btn{background:#2a3656;border:1px solid #3b4a74;color:var(--fg);padding:8px 12px;border-radius:10px}
  .hint{font-size:12px;color:var(--mut)}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);font-size:12px}
  #debug{font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <h2>Conjunctival ROI • Pallor + rPPG Demo</h2>
  <div class="hint">Open in <b>Safari on iPhone</b>, allow camera. Choose Rear/Selfie, then Start. HTTPS is required (Netlify / GitHub Pages).</div>

  <div class="controls card">
    <div class="pill">
      Camera:
      <label><input type="radio" name="cam" value="environment" checked> Rear</label>
      <label style="margin-left:8px;"><input type="radio" name="cam" value="user"> Selfie</label>
    </div>
    <button class="btn" id="btnStart">Start Camera</button>
    <button class="btn" id="btnStop">Stop</button>
    <button class="btn" id="btnRecord">Record 10s → Analyze</button>
    <span class="pill" id="recStatus">Idle</span>
  </div>

  <div class="stack">
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div class="card">
    <div class="row">
      <div class="metric"><h4>Focus (VarLap)</h4><div id="mFocus" class="val">—</div></div>
      <div class="metric"><h4>Motion MAD</h4><div id="mMotion" class="val">—</div></div>
      <div class="metric"><h4>Glare %</h4><div id="mGlare" class="val">—</div></div>
      <div class="metric"><h4>ROI coverage</h4><div id="mRoi" class="val">—</div></div>
      <div class="metric"><h4>Status</h4><div id="mStatus" class="val">—</div></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div class="metric"><h4>Pallor: mean R</h4><div id="pR" class="val">—</div></div>
      <div class="metric"><h4>Pallor: mean G</h4><div id="pG" class="val">—</div></div>
      <div class="metric"><h4>Pallor: mean B</h4><div id="pB" class="val">—</div></div>
      <div class="metric"><h4>Pallor: R/G</h4><div id="pRG" class="val">—</div></div>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div class="metric"><h4>rPPG HR (BPM)</h4><div id="rHR" class="val">—</div></div>
      <div class="metric"><h4>rPPG AC/DC</h4><div id="rACDC" class="val">—</div></div>
      <div class="metric"><h4>rPPG SNR</h4><div id="rSNR" class="val">—</div></div>
    </div>
    <canvas id="plot" class="plot"></canvas>
  </div>

  <div class="card">
    <b>Debug:</b> <span id="debug" class="hint">Ready.</span>
  </div>

  <div class="hint">If ROI isn’t found, the app falls back to a center band under the eye so you can still record and analyze.</div>
</div>

<!-- MediaPipe FaceMesh (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>

<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const plot = document.getElementById('plot');
const pctx = plot.getContext('2d');
const dbg = document.getElementById('debug');

const ui = {
  focus: document.getElementById('mFocus'),
  motion: document.getElementById('mMotion'),
  glare: document.getElementById('mGlare'),
  roi: document.getElementById('mRoi'),
  status: document.getElementById('mStatus'),
  pR: document.getElementById('pR'),
  pG: document.getElementById('pG'),
  pB: document.getElementById('pB'),
  pRG: document.getElementById('pRG'),
  rHR: document.getElementById('rHR'),
  rACDC: document.getElementById('rACDC'),
  rSNR: document.getElementById('rSNR'),
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnRecord: document.getElementById('btnRecord'),
  recStatus: document.getElementById('recStatus'),
};

function logDebug(msg, isError=false){
  dbg.textContent = msg;
  dbg.className = isError ? 'bad' : 'hint';
}

// camera choice (rear/selfie)
function selectedFacingMode(){
  const radios = document.querySelectorAll('input[name="cam"]');
  for (const r of radios) if (r.checked) return r.value;
  return "environment";
}

// Thresholds (tune as needed)
const TH = { minVarLap: 80.0, maxMotion: 0.08, maxGlare: 0.10, minRoiFrac: 0.12 };

let running = false;
let faceMesh;
let faceMeshReady = false;
let lastGraySmall = null;
let roiPoly = null;
let greenSeries = [];
let sampleTimes = [];
const MAX_SERIES = 600;  // ~20s @30fps

// recording state
let recording = false;
let recordStart = 0;
let recTimer = null;

// UI helpers
function setClass(el, ok){ el.className = 'val ' + (ok ? 'ok':'warn'); }

function resizeCanvases() {
  overlay.width = video.videoWidth || 1280;
  overlay.height = video.videoHeight || 720;
  plot.width = overlay.width;
  plot.height = 120;
}

// Start/Stop camera
async function startCamera() {
  try {
    const mode = selectedFacingMode();
    const constraints = {
      video: { facingMode: { ideal: mode }, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    return new Promise(res => {
      video.onloadedmetadata = () => { video.play(); resizeCanvases(); res(); };
    });
  } catch (e) {
    logDebug('Camera error: ' + e.message, true);
    throw e;
  }
}

// Fallback ROI (center band)
function fallbackRoi(W,H){
  const y0 = H*0.40, y1 = H*0.60, x0 = W*0.20, x1 = W*0.80;
  return [{x:x0,y:y0},{x:x1,y:y0},{x:x1,y:y1},{x:x0,y:y1}];
}

// Geometry helpers
function drawPoly(poly, color='rgba(255,255,0,0.8)'){
  if (!poly || poly.length===0) return;
  ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(poly[0].x, poly[0].y);
  for (let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
  ctx.closePath(); ctx.stroke(); ctx.restore();
}
function polyBBox(poly){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9;
  for(const p of poly){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }
  return {minX,minY,maxX,maxY};
}
function pointInPoly(x,y,poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y;
    const inter=((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
    if(inter) inside=!inside;
  }
  return inside;
}

// Image helpers
function toGraySmall(imageData, w, h, outW=160, outH=120){
  const gray=new Uint8ClampedArray(outW*outH), data=imageData.data;
  for(let j=0;j<outH;j++){
    const ySrc=Math.floor(j*h/outH);
    for(let i=0;i<outW;i++){
      const xSrc=Math.floor(i*w/outW);
      const idx=(ySrc*w+xSrc)*4;
      const r=data[idx], g=data[idx+1], b=data[idx+2];
      gray[j*outW+i]=(0.299*r+0.587*g+0.114*b);
    }
  }
  return {gray,outW,outH};
}
function varianceOfLaplacian(gray,w,h){
  const k=[0,1,0,1,-4,1,0,1,0]; let sum=0,sumSq=0,n=0;
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let conv=0, idxK=0;
      for(let dy=-1;dy<=1;dy++)
        for(let dx=-1;dx<=1;dx++)
          conv += gray[(y+dy)*w+(x+dx)]*k[idxK++];
      sum+=conv; sumSq+=conv*conv; n++;
    }
  }
  if(n<2) return 0; const mean=sum/n; return sumSq/n - mean*mean;
}
function normalizedMADDiff(prev,curr){
  let sumAbs=0,sumCurr=0,n=curr.length;
  for(let i=0;i<n;i++){ sumAbs+=Math.abs(curr[i]-prev[i]); sumCurr+=curr[i]; }
  const meanI=Math.max(1,sumCurr/n);
  return (sumAbs/n)/meanI;
}
function glareFraction(imageData, poly){
  const {width:w,height:h,data}=imageData; const bb=polyBBox(poly);
  let count=0, bright=0;
  const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(w-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(h-1,Math.ceil(bb.maxY));
  for(let y=minY;y<=maxY;y++){
    for(let x=minX;x<=maxX;x++){
      if(!pointInPoly(x,y,poly)) continue;
      const idx=(y*w+x)*4; const r=data[idx], g=data[idx+1], b=data[idx+2];
      const Y=0.299*r+0.587*g+0.114*b; count++; if(Y>=245) bright++;
    }
  } if(count===0) return 1.0; return bright/count;
}
function meanRGB(imageData, poly){
  const {width:w,height:h,data}=imageData; const bb=polyBBox(poly);
  let sr=0,sg=0,sb=0,n=0;
  const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(w-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(h-1,Math.ceil(bb.maxY));
  for(let y=minY;y<=maxY;y++){
    for(let x=minX;x<=maxX;x++){
      if(!pointInPoly(x,y,poly)) continue;
      const idx=(y*w+x)*4; sr+=data[idx]; sg+=data[idx+1]; sb+=data[idx+2]; n++;
    }
  } if(n===0) return {r:0,g:0,b:0,n:0};
  return {r:sr/n,g:sg/n,b:sb/n,n};
}
function area(poly){ const bb=polyBBox(poly); return Math.max(0,(bb.maxX-bb.minX))*Math.max(0,(bb.maxY-bb.minY)); }

// Build band under lower eyelid (right eye) using FaceMesh indices
function lowerEyelidBand(lm, W, H, rightEye=true){
  // Robust to landmark variants: try both eyes; default to right if available
  const sets = [
    [33, 159, 145, 133], // right-ish
    [263, 386, 374, 362] // left-ish
  ];
  const ids = rightEye ? sets[0] : sets[1];
  const pts = ids.map(i => ({ x: lm[i].x*W, y: lm[i].y*H }));
  const left=pts[0], lower=pts[2], right=pts[3];
  const pad=Math.max(10,Math.abs(right.x-left.x)*0.1);
  const x0=Math.min(left.x,right.x)-pad, x1=Math.max(left.x,right.x)+pad;
  const y0=lower.y+4, bandH=Math.max(10, (right.y+left.y+lower.y)/3 - lower.y + 12);
  const y1=y0+bandH;
  return [{x:x0,y:y0},{x:x1,y:y0},{x:x1,y:y1},{x:x0,y:y1}];
}

// simple line plot
function plotSeries(series){
  const w=plot.width, h=plot.height; pctx.clearRect(0,0,w,h);
  if(series.length<2) return;
  const maxV=Math.max(...series), minV=Math.min(...series), rng=Math.max(1e-3,maxV-minV);
  pctx.strokeStyle="#7ef5d6"; pctx.lineWidth=2; pctx.beginPath();
  for(let i=0;i<series.length;i++){
    const x=i*(w/(series.length-1));
    const y=h-((series[i]-minV)/rng)*h;
    if(i===0) pctx.moveTo(x,y); else pctx.lineTo(x,y);
  } pctx.stroke();
}

// detrend via moving average
function detrend(arr, win=21){
  const out=new Array(arr.length).fill(0);
  for(let i=0;i<arr.length;i++){
    const a=Math.max(0,i-Math.floor(win/2)), b=Math.min(arr.length-1,i+Math.floor(win/2));
    let s=0; for(let k=a;k<=b;k++) s+=arr[k];
    const m=s/(b-a+1); out[i]=arr[i]-m;
  } return out;
}
function hamming(N){ const w=new Array(N); for(let n=0;n<N;n++) w[n]=0.54-0.46*Math.cos(2*Math.PI*n/(N-1)); return w; }
// naive DFT power at specific frequencies
function periodogramDFT(x, fs, freqList){
  const N=x.length, pow=new Array(freqList.length).fill(0);
  for(let k=0;k<freqList.length;k++){
    const f=freqList[k], w=2*Math.PI*f/fs; let real=0, imag=0;
    for(let n=0;n<N;n++){ const phi=w*n; real+=x[n]*Math.cos(phi); imag-=x[n]*Math.sin(phi); }
    pow[k]= (real*real+imag*imag)/N;
  } return pow;
}

// rPPG features from last ~10 s
function analyzeRppg(times, vals){
  if (times.length<50) return {hr:null, acdc:null, snr:null};
  const dur=Math.max(0.1, times[times.length-1]-times[0]);
  const fs=25, M=Math.max(64, Math.min(256, Math.round(dur*fs)));
  const t0=times[0], tStep=dur/(M-1);
  const xs=new Array(M);
  for(let i=0;i<M;i++){
    const t=t0+i*tStep;
    let j=0; while(j<times.length-1 && times[j]<t) j++;
    xs[i]=vals[Math.max(0, Math.min(times.length-1, j))];
  }
  let x=detrend(xs, Math.round(fs*0.8));
  const win=hamming(x.length); for(let i=0;i<x.length;i++) x[i]*=win[i];

  const mean = xs.reduce((a,b)=>a+b,0)/xs.length;
  const sd = Math.sqrt(x.reduce((a,b)=>a+b*b,0)/x.length);
  const acdc = mean>0 ? (sd/mean) : null;

  const fmin=0.8, fmax=3.5, step=0.02;
  const freqs=[]; for(let f=fmin; f<=fmax; f+=step) freqs.push(f);
  const P=periodogramDFT(x, fs, freqs);
  let iMax=0; for(let i=1;i<P.length;i++) if(P[i]>P[iMax]) iMax=i;
  const fPeak=freqs[iMax]; const hr=Math.round(fPeak*60);
  const side=[]; for(let i=0;i<P.length;i++){
    if(Math.abs(freqs[i]-fPeak)>0.06 && Math.abs(freqs[i]-fPeak)<0.5) side.push(P[i]);
  }
  const median = side.length? side.slice().sort((a,b)=>a-b)[Math.floor(side.length/2)] : 1e-6;
  const snr = (P[iMax]/Math.max(1e-6,median)).toFixed(2);

  return {hr, acdc: acdc ? acdc.toFixed(4):null, snr};
}

// FaceMesh init
async function initFaceMesh(){
  faceMesh = new FaceMesh.FaceMesh({ locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
  faceMesh.onResults(onResults);
  faceMeshReady = true;
  logDebug('FaceMesh initialized.');
}

// ROI from FaceMesh (band under lower eyelid); if fail -> fallback
function buildRoiFromLandmarks(lm, W, H){
  try {
    const band = lowerEyelidBand(lm, W, H, true);
    return band;
  } catch(e){
    return fallbackRoi(W,H);
  }
}

// Main results callback
function onResults(res){
  if(!running) return;
  ctx.save();
  // Mirror for selfie for intuitive aiming
  if (selectedFacingMode()==="user") { ctx.translate(overlay.width, 0); ctx.scale(-1, 1); }
  ctx.drawImage(res.image,0,0,overlay.width,overlay.height);

  // ROI
  roiPoly = null;
  if (res.multiFaceLandmarks && res.multiFaceLandmarks.length>0) {
    roiPoly = buildRoiFromLandmarks(res.multiFaceLandmarks[0], overlay.width, overlay.height);
    drawPoly(roiPoly);
  } else {
    // no face detected → fallback band so user can still record & analyze
    roiPoly = fallbackRoi(overlay.width, overlay.height);
    drawPoly(roiPoly, 'rgba(0,200,255,0.8)');
  }
  ctx.restore();

  computeMetricsAndUpdateUI();
}

// Compute metrics per frame and update visuals
function computeMetricsAndUpdateUI(){
  const frame = ctx.getImageData(0,0,overlay.width,overlay.height);
  const {gray,outW,outH} = toGraySmall(frame, overlay.width, overlay.height);
  const varLap = varianceOfLaplacian(gray,outW,outH);
  const motion = lastGraySmall ? normalizedMADDiff(lastGraySmall, gray) : 0.0;
  lastGraySmall = gray;

  let glare=1.0, rgb={r:0,g:0,b:0,n:0}, roiFrac=0;
  if (roiPoly) {
    glare = glareFraction(frame, roiPoly);
    rgb = meanRGB(frame, roiPoly);
    const a = area(roiPoly); roiFrac = a/(overlay.width*overlay.height);
  }

  // live pallor features
  if (rgb.n>0){
    ui.pR.textContent = rgb.r.toFixed(0);
    ui.pG.textContent = rgb.g.toFixed(0);
    ui.pB.textContent = rgb.b.toFixed(0);
    ui.pRG.textContent = (rgb.g>0 ? (rgb.r/rgb.g).toFixed(3) : "—");
  }

  // quality gates
  const focusOk = varLap>=TH.minVarLap;
  const motionOk = motion<=TH.maxMotion || !lastGraySmall;
  const glareOk = glare<=TH.maxGlare;
  const roiOk = roiFrac>=TH.minRoiFrac;
  const pass = focusOk && motionOk && glareOk && roiOk;

  ui.focus.textContent = varLap.toFixed(0); setClass(ui.focus, focusOk);
  ui.motion.textContent = motion.toFixed(3); setClass(ui.motion, motionOk);
  ui.glare.textContent  = (glare*100).toFixed(1)+"%"; setClass(ui.glare, glareOk);
  ui.roi.textContent    = (roiFrac*100).toFixed(1)+"%"; setClass(ui.roi, roiOk);
  ui.status.textContent = pass ? "PASS" : "Adjust aim / light / stability"; setClass(ui.status, pass);

  // rPPG stream: mean GREEN in ROI
  const now = performance.now()/1000;
  if (rgb.n>0){
    greenSeries.push(rgb.g);
    sampleTimes.push(now);
    if (greenSeries.length>MAX_SERIES) { greenSeries.splice(0,greenSeries.length-MAX_SERIES); sampleTimes.splice(0,sampleTimes.length-MAX_SERIES); }
    plotSeries(greenSeries);
  }
}

// Animation loop: if FaceMesh didn’t run yet, paint current video frame + fallback ROI so record still works
async function loop(){
  if(!running) return;
  try {
    if (faceMeshReady) {
      await faceMesh.send({ image: video });
    } else {
      // draw raw frame with fallback ROI (before FaceMesh loads)
      ctx.drawImage(video,0,0,overlay.width,overlay.height);
      roiPoly = fallbackRoi(overlay.width, overlay.height);
      drawPoly(roiPoly, 'rgba(0,200,255,0.8)');
      computeMetricsAndUpdateUI();
    }
  } catch(e){
    logDebug('Loop error: ' + e.message, true);
  }
  requestAnimationFrame(loop);
}

// Start / Stop / Record controls
async function start(){
  ui.btnRecord.disabled = true;
  logDebug('Starting camera…');
  await startCamera();
  resizeCanvases();
  logDebug('Initializing FaceMesh…');
  try { await initFaceMesh(); } catch(e){ logDebug('FaceMesh init error: '+e.message, true); }
  running = true;
  ui.recStatus.textContent = "Live";
  ui.btnRecord.disabled = false;
  loop();
}
function stop(){
  running = false;
  const s = video.srcObject; if (s) s.getTracks().forEach(t=>t.stop());
  video.srcObject = null;
  cancelCountdown();
  ui.recStatus.textContent = "Idle";
  logDebug('Stopped.');
}
function startRecording(){
  if(!running || recording) return;
  recording = true; recordStart = performance.now()/1000;
  ui.btnRecord.disabled = true;
  let left = 10.0;
  ui.recStatus.textContent = `Recording: ${left.toFixed(1)}s`;
  recTimer = setInterval(()=>{
    left = Math.max(0, 10 - (performance.now()/1000 - recordStart));
    ui.recStatus.textContent = `Recording: ${left.toFixed(1)}s`;
    if (left <= 0.0) stopRecordingAndAnalyze();
  }, 100);
}
function cancelCountdown(){ if(recTimer){ clearInterval(recTimer); recTimer=null; } }
function stopRecordingAndAnalyze(){
  cancelCountdown();
  recording = false;
  ui.recStatus.textContent = "Analyzing…";
  // last ~10s
  const now = sampleTimes.length? sampleTimes[sampleTimes.length-1] : 0;
  const idx = sampleTimes.findIndex(t => t>= now-10);
  const times = idx>=0 ? sampleTimes.slice(idx) : sampleTimes.slice();
  const vals  = idx>=0 ? greenSeries.slice(idx)  : greenSeries.slice();
  const res = analyzeRppg(times, vals);
  ui.rHR.textContent = res.hr ? res.hr.toString() : "—";
  ui.rACDC.textContent = res.acdc ? res.acdc : "—";
  ui.rSNR.textContent = res.snr ? res.snr : "—";
  ui.recStatus.textContent = "Done";
  ui.btnRecord.disabled = false;
}

// Wire up buttons
ui.btnStart.onclick = async ()=>{ if(!running) await start(); };
ui.btnStop.onclick = ()=> stop();
ui.btnRecord.onclick = ()=> startRecording();

// Basic runtime checks
window.addEventListener('error', e => logDebug('JS error: ' + e.message, true));
if (!('mediaDevices' in navigator)) logDebug('Error: mediaDevices not available (use Safari over HTTPS).', true);
</script>
</body>
</html>
