<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<title>Conjunctival Strip • Compact UI Demo</title>
<style>
  :root { --fg:#e8f0ff; --bg:#0b1220; --mut:#a8b4d9; --ok:#95f395; --warn:#ffd27d; --bad:#ff7d7d; --card:rgba(255,255,255,.06); --line:rgba(255,255,255,.12);}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{padding:10px 10px calc(76px + env(safe-area-inset-bottom)); max-width:980px; margin:0 auto; display:flex; flex-direction:column; gap:10px;}
  h2{margin:.2rem 0 .4rem}
  .hint{font-size:12px;color:var(--mut)}
  .grid{display:grid; grid-template-columns: 1fr 320px; gap:10px;}
  @media (max-width:800px){ .grid{grid-template-columns:1fr;} }
  .stack{position:relative}
  #video{display:none}
  #overlay{width:100%; max-height:360px; border-radius:12px; background:#000;}
  .card{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:10px}
  .row{display:flex; flex-wrap:wrap; gap:10px}
  .metric{flex:1 1 30%; min-width:120px}
  .metric h4{margin:.1rem 0; color:var(--mut); font-size:12px}
  .metric .val{font-size:16px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .plot{height:110px; background:rgba(0,0,0,.3); border-radius:8px; width:100%}
  .thumb{width:100%; height:auto; border-radius:10px; background:#000}
  /* Right rail sticks near top for aiming */
  .rail{position:sticky; top:8px; display:flex; flex-direction:column; gap:10px}
  .rail h3{margin:.2rem 0 .4rem; font-size:14px; color:var(--mut)}
  /* bottom dock controls */
  .dock{
    position:fixed; left:0; right:0; bottom:0;
    padding:8px 10px calc(8px + env(safe-area-inset-bottom));
    background:rgba(10,14,26,.9); backdrop-filter: blur(10px);
    border-top:1px solid var(--line);
    display:flex; gap:8px; align-items:center; justify-content:space-between; z-index:50;
  }
  .pill{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.15); font-size:12px; display:flex; gap:8px; align-items:center;}
  .btn{background:#2a3656; border:1px solid #3b4a74; color:var(--fg); padding:10px 12px; border-radius:12px; font-weight:600}
  .btn[disabled]{opacity:.5}
  #recStatus{font-size:12px}
  #debug{font-size:12px}
</style>
</head>
<body>
<div class="wrap">
  <h2>Conjunctival Strip • Compact UI</h2>
  <div class="hint">Safari on iPhone, HTTPS (GitHub Pages). Choose camera in the dock ➜ Start Camera ➜ Record.</div>

  <div class="grid">
    <!-- LEFT: Live view + metrics -->
    <div class="left">
      <div class="stack">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>Focus (VarLap)</h4><div id="mFocus" class="val">—</div></div>
          <div class="metric"><h4>Motion MAD</h4><div id="mMotion" class="val">—</div></div>
          <div class="metric"><h4>Glare %</h4><div id="mGlare" class="val">—</div></div>
          <div class="metric"><h4>ROI coverage</h4><div id="mRoi" class="val">—</div></div>
          <div class="metric"><h4>Status</h4><div id="mStatus" class="val">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>Pallor: mean R</h4><div id="pR" class="val">—</div></div>
          <div class="metric"><h4>Pallor: mean G</h4><div id="pG" class="val">—</div></div>
          <div class="metric"><h4>Pallor: mean B</h4><div id="pB" class="val">—</div></div>
          <div class="metric"><h4>Pallor: R/G</h4><div id="pRG" class="val">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>rPPG HR (BPM)</h4><div id="rHR" class="val">—</div></div>
          <div class="metric"><h4>rPPG AC/DC</h4><div id="rACDC" class="val">—</div></div>
          <div class="metric"><h4>rPPG SNR</h4><div id="rSNR" class="val">—</div></div>
        </div>
        <canvas id="plot" class="plot"></canvas>
      </div>

      <div class="card">
        <b>Debug:</b> <span id="debug" class="hint">Ready.</span>
      </div>
    </div>

    <!-- RIGHT: Aiming crop + Vesselness -->
    <div class="rail">
      <div class="card">
        <h3>Aiming crop (live)</h3>
        <canvas id="aimView" width="320" height="220" class="thumb"></canvas>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>ROI View (10-s)</h4></div>
          <div class="metric"><h4>Vesselness (10-s avg)</h4></div>
        </div>
        <div class="row">
          <canvas id="roiView" width="240" height="160" class="thumb"></canvas>
          <canvas id="vesselView" width="240" height="160" class="thumb"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Bottom dock controls (always visible) -->
<div class="dock">
  <div class="pill">
    <span>Camera:</span>
    <label><input type="radio" name="cam" value="environment" checked> Rear</label>
    <label><input type="radio" name="cam" value="user"> Selfie</label>
    <span id="recStatus">Idle</span>
  </div>
  <div style="display:flex; gap:8px;">
    <button class="btn" id="btnStart">Start Camera</button>
    <button class="btn" id="btnStop">Stop</button>
    <button class="btn" id="btnRecord">Record 10s → Analyze</button>
  </div>
</div>

<!-- MediaPipe FaceMesh (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>

<script>
/* ---------- Elements ---------- */
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const plot = document.getElementById('plot');
const pctx = plot.getContext('2d');

const aimCanvas = document.getElementById('aimView');
const aimCtx = aimCanvas.getContext('2d');

const roiCanvas = document.getElementById('roiView');
const vesselCanvas = document.getElementById('vesselView');
const roiCtx = roiCanvas.getContext('2d');
const vesselCtx = vesselCanvas.getContext('2d');

const dbg = document.getElementById('debug');
const ui = {
  focus: document.getElementById('mFocus'),
  motion: document.getElementById('mMotion'),
  glare: document.getElementById('mGlare'),
  roi: document.getElementById('mRoi'),
  status: document.getElementById('mStatus'),
  pR: document.getElementById('pR'), pG: document.getElementById('pG'), pB: document.getElementById('pB'), pRG: document.getElementById('pRG'),
  rHR: document.getElementById('rHR'), rACDC: document.getElementById('rACDC'), rSNR: document.getElementById('rSNR'),
  btnStart: document.getElementById('btnStart'), btnStop: document.getElementById('btnStop'), btnRecord: document.getElementById('btnRecord'),
  recStatus: document.getElementById('recStatus'),
};

/* ---------- Helpers & thresholds ---------- */
function logDebug(msg, isError=false){ dbg.textContent = msg; dbg.className = isError ? 'bad' : 'hint'; }
function selectedFacingMode(){ const r=[...document.querySelectorAll('input[name="cam"]')].find(x=>x.checked); return r? r.value : "environment"; }
function setClass(el, ok){ el.className = 'val ' + (ok ? 'ok':'warn'); }
function resizeCanvases(){
  overlay.width = video.videoWidth || 1280;
  overlay.height = video.videoHeight || 720;
  plot.width = Math.min(overlay.width, 900);
  plot.height = 110;
}
const TH = { minVarLap: 80.0, maxMotion: 0.08, maxGlare: 0.10, minRoiFrac: 0.03 };

/* ---------- State ---------- */
let running=false, faceMesh, faceMeshReady=false, roiPoly=null;
let lastGraySmall=null, greenSeries=[], sampleTimes=[];
let vesselSum=null, vesselCount=0;
const MAX_SERIES=600;
let recording=false, recordStart=0, recTimer=null;

/* ---------- Camera ---------- */
async function startCamera(){
  try{
    const mode = selectedFacingMode();
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: mode }, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    video.srcObject = stream;
    return new Promise(res => { video.onloadedmetadata = () => { video.play(); resizeCanvases(); res(); }; });
  } catch(e){ logDebug('Camera error: ' + e.message, true); throw e; }
}
function stopCamera(){ const s = video.srcObject; if (s) s.getTracks().forEach(t=>t.stop()); video.srcObject = null; }

/* ---------- Geometry + ROI ---------- */
function polyBBox(poly){ let minX=1e9,minY=1e9,maxX=-1e9,maxY=-1e9; for(const p of poly){ if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; } return {minX,minY,maxX,maxY}; }
function pointInPoly(x,y,poly){ let inside=false; for(let i=0,j=poly.length-1;i<poly.length;j=i++){ const xi=poly[i].x, yi=poly[i].y, xj=poly[j].x, yj=poly[j].y; const inter=((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi); if(inter) inside=!inside; } return inside; }
function drawPolyFilled(poly, stroke='rgba(255,255,0,0.95)', fill='rgba(255,255,0,0.15)'){ if (!poly||!poly.length) return; ctx.save(); ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(poly[0].x, poly[0].y); for(let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); }
function fallbackRoi(W,H){ const y0=H*0.45,y1=y0+Math.max(8,H*0.03),x0=W*0.30,x1=W*0.70; return [{x:x0,y:y0},{x:x1,y:y0},{x:x1,y:y1},{x:x0,y:y1}]; }
function palpebralStripThin(lm, W, H, useRightEye=true){
  const lowerRight = [145,153,154,155,133,173,157,158,159];
  const lowerLeft  = [374,380,381,382,362,398,384,385,386];
  const ids = useRightEye ? lowerRight : lowerLeft;
  const pts = ids.map(i => ({ x: lm[i].x*W, y: lm[i].y*H }));
  const cornerR = useRightEye ? 33 : 263;
  const cornerL = useRightEye ? 133 : 362;
  const wEye = Math.hypot(lm[cornerR].x*W - lm[cornerL].x*W, lm[cornerR].y*H - lm[cornerL].y*H);
  const thickness = Math.max(4, Math.round(0.025 * wEye));
  const down = pts.map(p => ({ x: p.x, y: p.y + thickness }));
  return [...pts, ...down.reverse()];
}

/* ---------- Image ops ---------- */
function toGraySmall(imageData, w, h, outW=160, outH=120){
  const gray=new Uint8ClampedArray(outW*outH), data=imageData.data;
  for(let j=0;j<outH;j++){ const ySrc=Math.floor(j*h/outH);
    for(let i=0;i<outW;i++){ const xSrc=Math.floor(i*w/outW); const idx=(ySrc*w+xSrc)*4;
      const r=data[idx], g=data[idx+1], b=data[idx+2];
      gray[j*outW+i]=(0.299*r+0.587*g+0.114*b);
    }
  } return {gray,outW,outH};
}
function varianceOfLaplacian(gray,w,h){
  const k=[0,1,0,1,-4,1,0,1,0]; let sum=0,sumSq=0,n=0;
  for(let y=1;y<h-1;y++){ for(let x=1;x<w-1;x++){
    let conv=0, idxK=0;
    for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) conv += gray[(y+dy)*w+(x+dx)]*k[idxK++];
    sum+=conv; sumSq+=conv*conv; n++;
  }} if(n<2) return 0; const mean=sum/n; return sumSq/n - mean*mean;
}
function normalizedMADDiff(prev,curr){ let sumAbs=0,sumCurr=0,n=curr.length; for(let i=0;i<n;i++){ sumAbs+=Math.abs(curr[i]-prev[i]); sumCurr+=curr[i]; } const meanI=Math.max(1,sumCurr/n); return (sumAbs/n)/meanI; }
function glareFraction(imageData, poly){
  const {width:w,height:h,data}=imageData; const bb=polyBBox(poly);
  let count=0, bright=0;
  const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(w-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(h-1,Math.ceil(bb.maxY));
  for(let y=minY;y<=maxY;y++){ for(let x=minX;x<=maxX;x++){
    if(!pointInPoly(x,y,poly)) continue;
    const idx=(y*w+x)*4; const r=data[idx], g=data[idx+1], b=data[idx+2];
    const Y=0.299*r+0.587*g+0.114*b; count++; if(Y>=245) bright++;
  }} if(count===0) return 1.0; return bright/count;
}
function meanRGB(imageData, poly){
  const {width:w,height:h,data}=imageData; const bb=polyBBox(poly);
  let sr=0,sg=0,sb=0,n=0;
  const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(w-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(h-1,Math.ceil(bb.maxY));
  for(let y=minY;y<=maxY;y++){ for(let x=minX;x<=maxX;x++){
    if(!pointInPoly(x,y,poly)) continue;
    const idx=(y*w+x)*4; sr+=data[idx]; sg+=data[idx+1]; sb+=data[idx+2]; n++;
  }} if(n===0) return {r:0,g:0,b:0,n:0};
  return {r:sr/n,g:sg/n,b:sb/n,n};
}
function area(poly){ const bb=polyBBox(poly); return Math.max(0,(bb.maxX-bb.minX))*Math.max(0,(bb.maxY-bb.minY)); }

function boxBlur(gray, w, h, r=3){
  const tmp=new Float32Array(w*h), out=new Float32Array(w*h);
  for(let y=0;y<h;y++){ let sum=0;
    for(let x=0;x<w;x++){ const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
      if (x===0){ sum=0; for(let i=x0;i<=x1;i++) sum+=gray[y*w+i]; }
      else { const prev=Math.max(0,x-1-r), next=Math.min(w-1,x+r); sum += gray[y*w+next] - gray[y*w+prev]; }
      tmp[y*w+x] = sum / (x1-x0+1);
  }}
  for(let x=0;x<w;x++){ let sum=0;
    for(let y=0;y<h;y++){ const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
      if (y===0){ sum=0; for(let j=y0;j<=y1;j++) sum+=tmp[j*w+x]; }
      else { const prev=Math.max(0,y-1-r), next=Math.min(h-1,y+r); sum += tmp[next*w+x] - tmp[prev*w+x]; }
      out[y*w+x] = sum / (y1-y0+1);
  }} return out;
}

/* Conjunctiva mask */
function conjunctivaMask(imageData, roiPoly){
  const {width:W,height:H,data}=imageData;
  const bb=polyBBox(roiPoly);
  const x0=Math.max(0,Math.floor(bb.minX)), x1=Math.min(W-1,Math.ceil(bb.maxX));
  const y0=Math.max(0,Math.floor(bb.minY)), y1=Math.min(H-1,Math.ceil(bb.maxY));
  const outW=x1-x0+1, outH=y1-y0+1;
  const mask=new Uint8Array(outW*outH);
  for(let y=y0;y<=y1;y++){ for(let x=x0;x<=x1;x++){
    const idx=(y*W+x)*4; const r=data[idx], g=data[idx+1], b=data[idx+2];
    if(!pointInPoly(x,y,roiPoly)) continue;
    const maxv = Math.max(r,g,b), minv = Math.min(r,g,b);
    const V = maxv; const S = maxv ? (maxv - minv)/maxv : 0;
    const isSclera = (V>240 && S<0.12);
    const isLash   = (V<35);
    const looksConj = (!isSclera && !isLash && r>=g && g>=b && S>=0.10 && S<=0.65 && V>=50 && V<=230);
    mask[(y-y0)*outW + (x-x0)] = looksConj ? 1 : 0;
  }} return {mask, x0, y0, w:outW, h:outH};
}

function extractGreenConj(imageData, roiPoly, outW=240, outH=160){
  const {width:W,height:H,data} = imageData;
  const bb=polyBBox(roiPoly);
  const x0=Math.max(0,Math.floor(bb.minX)), y0=Math.max(0,Math.floor(bb.minY));
  const x1=Math.min(W-1,Math.ceil(bb.maxX)), y1=Math.min(H-1,Math.ceil(bb.maxY));
  const roiW=x1-x0+1, roiH=y1-y0+1;
  const {mask:m2, x0:mx0, y0:my0, w:mw, h:mh} = conjunctivaMask(imageData, roiPoly);
  const g=new Float32Array(outW*outH), mask=new Uint8Array(outW*outH);
  for(let j=0;j<outH;j++){
    const sy=y0 + Math.floor(j*roiH/outH);
    for(let i=0;i<outW;i++){
      const sx=x0 + Math.floor(i*roiW/outW);
      const idx=(sy*W+sx)*4;
      const mVal = (sx>=mx0 && sx<mx0+mw && sy>=my0 && sy<my0+mh) ? m2[(sy-my0)*mw + (sx-mx0)] : 0;
      mask[j*outW+i] = mVal ? 1 : 0;
      g[j*outW+i] = mVal ? data[idx+1] : 0;
    }
  }
  return {g,w:outW,h:outH,mask, bb:{x0,y0,x1,y1}};
}

function vesselnessTopHatMasked(g,w,h,mask,blurR=3){
  const blurred = boxBlur(g,w,h,blurR);
  const raw=new Float32Array(w*h); let maxv=1e-6;
  for(let i=0;i<w*h;i++){ const v=mask[i] ? Math.max(0, g[i]-blurred[i]) : 0; raw[i]=v; if(v>maxv) maxv=v; }
  const out=new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++) out[i]=Math.round(255*(raw[i]/maxv));
  return out;
}

/* ---------- rPPG ---------- */
function plotSeries(series){
  const w=plot.width,h=plot.height; pctx.clearRect(0,0,w,h);
  if(series.length<2) return;
  const maxV=Math.max(...series), minV=Math.min(...series), rng=Math.max(1e-3,maxV-minV);
  pctx.strokeStyle="#7ef5d6"; pctx.lineWidth=2; pctx.beginPath();
  for(let i=0;i<series.length;i++){ const x=i*(w/(series.length-1)); const y=h-((series[i]-minV)/rng)*h; if(i===0) pctx.moveTo(x,y); else pctx.lineTo(x,y); }
  pctx.stroke();
}
function detrend(arr, win=21){ const out=new Array(arr.length).fill(0); for(let i=0;i<arr.length;i++){ const a=Math.max(0,i-Math.floor(win/2)), b=Math.min(arr.length-1,i+Math.floor(win/2)); let s=0; for(let k=a;k<=b;k++) s+=arr[k]; const m=s/(b-a+1); out[i]=arr[i]-m; } return out; }
function hamming(N){ const w=new Array(N); for(let n=0;n<N;n++) w[n]=0.54-0.46*Math.cos(2*Math.PI*n/(N-1)); return w; }
function periodogramDFT(x, fs, freqList){ const N=x.length, pow=new Array(freqList.length).fill(0); for(let k=0;k<freqList.length;k++){ const f=freqList[k], w=2*Math.PI*f/fs; let re=0, im=0; for(let n=0;n<N;n++){ const phi=w*n; re+=x[n]*Math.cos(phi); im-=x[n]*Math.sin(phi); } pow[k]=(re*re+im*im)/N; } return pow; }
function analyzeRppg(times, vals){
  if (times.length<50) return {hr:null, acdc:null, snr:null};
  const dur=Math.max(0.1, times[times.length-1]-times[0]); const fs=25;
  const M=Math.max(64, Math.min(256, Math.round(dur*fs)));
  const t0=times[0], tStep=dur/(M-1); const xs=new Array(M);
  for(let i=0;i<M;i++){ const t=t0+i*tStep; let j=0; while(j<times.length-1 && times[j]<t) j++; xs[i]=vals[Math.max(0,Math.min(times.length-1,j))]; }
  let x=detrend(xs, Math.round(fs*0.8)); const win=hamming(x.length); for(let i=0;i<x.length;i++) x[i]*=win[i];
  const mean = xs.reduce((a,b)=>a+b,0)/xs.length; const sd = Math.sqrt(x.reduce((a,b)=>a+b*b,0)/x.length);
  const acdc = mean>0 ? (sd/mean) : null;
  const fmin=0.8,fmax=3.5,step=0.02; const freqs=[]; for(let f=fmin; f<=fmax; f+=step) freqs.push(f);
  const P=periodogramDFT(x,fs,freqs); let iMax=0; for(let i=1;i<P.length;i++) if(P[i]>P[iMax]) iMax=i;
  const fPeak=freqs[iMax]; const hr=Math.round(fPeak*60);
  const side=[]; for(let i=0;i<P.length;i++){ if(Math.abs(freqs[i]-fPeak)>0.06 && Math.abs(freqs[i]-fPeak)<0.5) side.push(P[i]); }
  const median = side.length? side.slice().sort((a,b)=>a-b)[Math.floor(side.length/2)] : 1e-6;
  const snr=(P[iMax]/Math.max(1e-6,median)).toFixed(2);
  return {hr, acdc: acdc ? acdc.toFixed(4):null, snr};
}

/* ---------- FaceMesh ---------- */
async function initFaceMesh(){
  faceMesh = new FaceMesh.FaceMesh({ locateFile: (f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5 });
  faceMesh.onResults(onResults);
  faceMeshReady=true; logDebug('FaceMesh initialized.');
}

/* ---------- Per-frame ---------- */
function computeMetricsAndUpdateUI(){
  const frame = ctx.getImageData(0,0,overlay.width,overlay.height);
  const {gray,outW,outH} = toGraySmall(frame, overlay.width, overlay.height);
  const varLap = varianceOfLaplacian(gray,outW,outH);
  const motion = lastGraySmall ? normalizedMADDiff(lastGraySmall, gray) : 0.0;
  lastGraySmall = gray;

  let glare=1.0, rgb={r:0,g:0,b:0,n:0}, roiFrac=0;
  if (roiPoly) {
    glare = glareFraction(frame, roiPoly);
    rgb = meanRGB(frame, roiPoly);
    roiFrac = area(roiPoly)/(overlay.width*overlay.height);
  }

  if (rgb.n>0){
    ui.pR.textContent = rgb.r.toFixed(0);
    ui.pG.textContent = rgb.g.toFixed(0);
    ui.pB.textContent = rgb.b.toFixed(0);
    ui.pRG.textContent = (rgb.g>0 ? (rgb.r/rgb.g).toFixed(3) : "—");
  }

  const focusOk = varLap>=TH.minVarLap;
  const motionOk = motion<=TH.maxMotion || !lastGraySmall;
  const glareOk = glare<=TH.maxGlare;
  const roiOk = roiFrac>=TH.minRoiFrac;
  const pass = focusOk && motionOk && glareOk && roiOk;

  ui.focus.textContent = varLap.toFixed(0); setClass(ui.focus, focusOk);
  ui.motion.textContent = motion.toFixed(3); setClass(ui.motion, motionOk);
  ui.glare.textContent  = (glare*100).toFixed(1)+"%"; setClass(ui.glare, glareOk);
  ui.roi.textContent    = (roiFrac*100).toFixed(2)+"%"; setClass(ui.roi, roiOk);
  ui.status.textContent = pass ? "PASS" : "Adjust aim / light / stability"; setClass(ui.status, pass);

  // rPPG stream
  const now = performance.now()/1000;
  if (rgb.n>0){
    greenSeries.push(rgb.g); sampleTimes.push(now);
    if (greenSeries.length>MAX_SERIES) { greenSeries.splice(0,greenSeries.length-MAX_SERIES); sampleTimes.splice(0,sampleTimes.length-MAX_SERIES); }
    plotSeries(greenSeries);
  }

  // Live aiming crop: show tight bbox around ROI scaled to aimView
  if (roiPoly){
    const bb = polyBBox(roiPoly);
    const padX = Math.max(8, (bb.maxX - bb.minX)*0.35);
    const padY = Math.max(8, (bb.maxY - bb.minY)*1.2);
    const x0 = Math.max(0, Math.floor(bb.minX - padX));
    const y0 = Math.max(0, Math.floor(bb.minY - padY));
    const x1 = Math.min(overlay.width-1, Math.ceil(bb.maxX + padX));
    const y1 = Math.min(overlay.height-1, Math.ceil(bb.maxY + padY));
    const w = x1 - x0 + 1, h = y1 - y0 + 1;
    // mirror selfie for intuitive aiming
    aimCtx.save();
    aimCtx.clearRect(0,0,aimCanvas.width,aimCanvas.height);
    if (selectedFacingMode()==="user") { aimCtx.translate(aimCanvas.width, 0); aimCtx.scale(-1,1); }
    aimCtx.drawImage(overlay, x0, y0, w, h, 0, 0, aimCanvas.width, aimCanvas.height);
    aimCtx.restore();
  }
}

function onResults(res){
  if(!running) return;
  ctx.save();
  if (selectedFacingMode()==="user") { ctx.translate(overlay.width, 0); ctx.scale(-1, 1); } // mirror selfie
  ctx.drawImage(res.image,0,0,overlay.width,overlay.height);
  roiPoly = null;
  if (res.multiFaceLandmarks && res.multiFaceLandmarks.length>0) {
    roiPoly = palpebralStripThin(res.multiFaceLandmarks[0], overlay.width, overlay.height, true);
    drawPolyFilled(roiPoly);
  } else {
    roiPoly = fallbackRoi(overlay.width, overlay.height);
    drawPolyFilled(roiPoly, 'rgba(0,200,255,0.95)','rgba(0,200,255,0.18)');
  }
  ctx.restore();
  computeMetricsAndUpdateUI();
}

/* ---------- Loop ---------- */
async function loop(){
  if(!running) return;
  try {
    if (faceMeshReady) { await faceMesh.send({ image: video }); }
    else {
      ctx.drawImage(video,0,0,overlay.width,overlay.height);
      roiPoly = fallbackRoi(overlay.width, overlay.height);
      drawPolyFilled(roiPoly, 'rgba(0,200,255,0.95)','rgba(0,200,255,0.18)');
      computeMetricsAndUpdateUI();
    }
  } catch(e){ logDebug('Loop error: ' + e.message, true); }
  requestAnimationFrame(loop);
}

/* ---------- Record / Analyze ---------- */
function vesselnessTopHatMasked(g,w,h,mask,blurR=3){
  const blurred = boxBlur(g,w,h,blurR);
  const raw=new Float32Array(w*h); let maxv=1e-6;
  for(let i=0;i<w*h;i++){ const v=mask[i] ? Math.max(0, g[i]-blurred[i]) : 0; raw[i]=v; if(v>maxv) maxv=v; }
  const out=new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++) out[i]=Math.round(255*(raw[i]/maxv));
  return out;
}

function startRecording(){
  if(!running || recording) return;
  recording=true; recordStart=performance.now()/1000; ui.btnRecord.disabled=true;
  vesselSum=null; vesselCount=0;
  roiCtx.clearRect(0,0,roiCanvas.width,roiCanvas.height);
  vesselCtx.clearRect(0,0,vesselCanvas.width,vesselCanvas.height);
  let left=10.0; ui.recStatus.textContent=`Recording: ${left.toFixed(1)}s`;
  recTimer=setInterval(()=>{
    left = Math.max(0, 10 - (performance.now()/1000 - recordStart));
    ui.recStatus.textContent = `Recording: ${left.toFixed(1)}s`;
    if (left<=0.0) stopRecordingAndAnalyze();
  },100);
}
function cancelCountdown(){ if(recTimer){ clearInterval(recTimer); recTimer=null; } }
function stopRecordingAndAnalyze(){
  cancelCountdown(); recording=false; ui.recStatus.textContent="Analyzing…";

  // rPPG (last ~10s)
  const now = sampleTimes.length? sampleTimes[sampleTimes.length-1] : 0;
  const idx = sampleTimes.findIndex(t => t>= now-10);
  const times = idx>=0 ? sampleTimes.slice(idx) : sampleTimes.slice();
  const vals  = idx>=0 ? greenSeries.slice(idx)  : greenSeries.slice();
  const res = analyzeRppg(times, vals);
  ui.rHR.textContent   = res.hr   ? res.hr.toString() : "—";
  ui.rACDC.textContent = res.acdc ? res.acdc : "—";
  ui.rSNR.textContent  = res.snr  ? res.snr  : "—";

  // Vesselness avg rendering from masked ROI
  const frame = ctx.getImageData(0,0,overlay.width,overlay.height);
  if (roiPoly){
    const crop = extractGreenConj(frame, roiPoly, roiCanvas.width, roiCanvas.height);
    // During recording, we also accumulated, but if not, just draw once
    if (!vesselSum) { vesselSum = new Float32Array(crop.w*crop.h); vesselCount=1; }
    const enh  = vesselnessTopHatMasked(crop.g, crop.w, crop.h, crop.mask, 3);
    for (let i=0;i<enh.length;i++) vesselSum[i] += enh[i];

    const avg = new Uint8ClampedArray(vesselSum.length);
    let maxv=1e-6; for(let i=0;i<vesselSum.length;i++) if(vesselSum[i]>maxv) maxv=vesselSum[i];
    for (let i=0;i<avg.length;i++) avg[i]=Math.round(255*(vesselSum[i]/maxv));
    const vsImg = vesselCtx.createImageData(roiCanvas.width, roiCanvas.height);
    for (let i=0;i<avg.length;i++){
      const v=avg[i]; vsImg.data[4*i+0]=v*0.6; vsImg.data[4*i+1]=v; vsImg.data[4*i+2]=v*0.8; vsImg.data[4*i+3]=255;
    }
    vesselCtx.putImageData(vsImg,0,0);

    // Also show the final masked ROI view
    const roiImg = roiCtx.createImageData(crop.w, crop.h);
    for (let i=0;i<crop.w*crop.h;i++){
      const v = crop.mask[i] ? Math.round(crop.g[i]) : 0;
      roiImg.data[4*i+0]=v; roiImg.data[4*i+1]=v; roiImg.data[4*i+2]=v; roiImg.data[4*i+3]=255;
    }
    roiCtx.putImageData(roiImg, 0, 0);
  }

  ui.recStatus.textContent="Done"; ui.btnRecord.disabled=false;
}

/* ---------- Controls ---------- */
async function start(){
  ui.btnRecord.disabled = true;
  logDebug('Starting camera…');
  await startCamera(); resizeCanvases();
  logDebug('Initializing FaceMesh…');
  try { await initFaceMesh(); } catch(e){ logDebug('FaceMesh init error: '+e.message, true); }
  running = true; ui.recStatus.textContent = "Live"; ui.btnRecord.disabled = false; loop();
}
function stop(){ running=false; stopCamera(); cancelCountdown(); ui.recStatus.textContent="Idle"; logDebug('Stopped.'); }

ui.btnStart.onclick = async ()=>{ if(!running) await start(); };
ui.btnStop.onclick  = ()=> stop();
ui.btnRecord.onclick= ()=> startRecording();

/* ---------- Runtime guard ---------- */
window.addEventListener('error', e => logDebug('JS error: ' + e.message, true));
if (!('mediaDevices' in navigator)) logDebug('Error: mediaDevices not available (use Safari over HTTPS).', true);
</script>
</body>
</html>
