<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Conjunctival Eye ROI • Ellipse + rPPG (fixed AR)</title>
<style>
  :root{--fg:#e8f0ff;--bg:#0b1220;--mut:#a8b4d9;--ok:#95f395;--warn:#ffd27d;--bad:#ff7d7d;--card:rgba(255,255,255,.06);--line:rgba(255,255,255,.12)}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial}
  h2{margin:.2rem 0 .4rem}
  .wrap{padding:10px 10px calc(76px + env(safe-area-inset-bottom));max-width:980px;margin:0 auto;display:flex;flex-direction:column;gap:10px}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:10px}
  @media (max-width:800px){.grid{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:10px}
  .row{display:flex;flex-wrap:wrap;gap:10px}
  .metric{flex:1 1 30%;min-width:120px}
  .metric h4{margin:.1rem 0;color:var(--mut);font-size:12px}
  .metric .val{font-size:16px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  .hint{font-size:12px;color:var(--mut)}
  .stack{position:relative}
  #video{display:none}
  /* The canvas scales responsively with preserved aspect ratio (set from JS) */
  #overlay{width:100%;height:auto;display:block;border-radius:12px;background:#000;max-height:360px}
  .plot{height:110px;background:rgba(0,0,0,.3);border-radius:8px;width:100%}
  .rail{position:sticky;top:8px;display:flex;flex-direction:column;gap:10px}
  .rail h3{margin:.2rem 0 .4rem;font-size:14px;color:var(--mut)}
  .thumb{width:100%;height:auto;border-radius:10px;background:#000;display:block}
  .legend{font-size:11px;color:var(--mut);margin-top:6px}
  .dock{position:fixed;left:0;right:0;bottom:0;padding:8px 10px calc(8px + env(safe-area-inset-bottom));background:rgba(10,14,26,.9);backdrop-filter:blur(10px);border-top:1px solid var(--line);display:flex;gap:8px;align-items:center;justify-content:space-between;z-index:50}
  .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);font-size:12px;display:flex;gap:8px;align-items:center}
  .btn{background:#2a3656;border:1px solid #3b4a74;color:var(--fg);padding:10px 12px;border-radius:12px;font-weight:600}
  .btn[disabled]{opacity:.5}
  #recStatus{font-size:12px}
  #debug{font-size:12px}
  label{user-select:none}
</style>
</head>
<body>
<div class="wrap">
  <h2>Conjunctival Eye ROI • Rotated Ellipse</h2>
  <div class="hint">Use Selfie, center ONE eye. Buttons are fixed at bottom. If you see a cyan dashed bar, landmarks were lost (fallback).</div>

  <div class="grid">
    <div>
      <div class="stack">
        <video id="video" playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>Focus (VarLap)</h4><div id="mFocus" class="val">—</div></div>
          <div class="metric"><h4>Motion MAD</h4><div id="mMotion" class="val">—</div></div>
          <div class="metric"><h4>Glare %</h4><div id="mGlare" class="val">—</div></div>
          <div class="metric"><h4>ROI coverage</h4><div id="mRoi" class="val">—</div></div>
          <div class="metric"><h4>Status</h4><div id="mStatus" class="val">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>Pallor: mean R</h4><div id="pR" class="val">—</div></div>
          <div class="metric"><h4>Pallor: mean G</h4><div id="pG" class="val">—</div></div>
          <div class="metric"><h4>Pallor: mean B</h4><div id="pB" class="val">—</div></div>
          <div class="metric"><h4>Pallor: R/G</h4><div id="pRG" class="val">—</div></div>
        </div>
      </div>

      <div class="card">
        <div class="row">
          <div class="metric"><h4>rPPG HR (BPM)</h4><div id="rHR" class="val">—</div></div>
          <div class="metric"><h4>rPPG AC/DC</h4><div id="rACDC" class="val">—</div></div>
          <div class="metric"><h4>rPPG SNR</h4><div id="rSNR" class="val">—</div></div>
        </div>
        <canvas id="plot" class="plot"></canvas>
      </div>

      <div class="card">
        <b>Debug:</b> <span id="debug" class="hint">Ready.</span>
      </div>
    </div>

    <div class="rail">
      <div class="card">
        <h3>Aiming crop (live)</h3>
        <canvas id="aimView" width="320" height="220" class="thumb"></canvas>
      </div>
      <div class="card">
        <div class="row">
          <div class="metric"><h4>Masked ROI (10 s)</h4></div>
          <div class="metric"><h4>Vesselness (10 s avg)</h4></div>
        </div>
        <div class="row">
          <canvas id="roiView" width="240" height="160" class="thumb"></canvas>
          <canvas id="vesselView" width="240" height="160" class="thumb"></canvas>
        </div>
        <div class="legend">Bright lines = stronger linear structures (capillary-like) within masked conjunctiva. Smooth, faint = poor focus/lighting/motion.</div>
      </div>
    </div>
  </div>
</div>

<div class="dock">
  <div class="pill">
    <span>Camera:</span>
    <label><input type="radio" name="cam" value="environment"> Rear</label>
    <label><input type="radio" name="cam" value="user" checked> Selfie</label>
    <label><input type="checkbox" id="eyeSide" checked> Right eye</label>
    <span id="recStatus">Idle</span>
  </div>
  <div style="display:flex;gap:8px">
    <button class="btn" id="btnStart">Start Camera</button>
    <button class="btn" id="btnStop">Stop</button>
    <button class="btn" id="btnRecord">Record 10s → Analyze</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>
<script>
/* Elements */
const video = document.getElementById('video');
const overlay = document.getElementById('overlay'); const ctx = overlay.getContext('2d');
const aimCanvas = document.getElementById('aimView'); const aimCtx = aimCanvas.getContext('2d');
const roiCanvas = document.getElementById('roiView'); const roiCtx = roiCanvas.getContext('2d');
const vesselCanvas = document.getElementById('vesselView'); const vesselCtx = vesselCanvas.getContext('2d');
const plot = document.getElementById('plot'); const pctx = plot.getContext('2d');
const dbg = document.getElementById('debug');
const ui = {
  focus: mFocus, motion: mMotion, glare: mGlare, roi: mRoi, status: mStatus,
  pR, pG, pB, pRG, rHR, rACDC, rSNR,
  btnStart: btnStart, btnStop: btnStop, btnRecord: btnRecord, recStatus: recStatus,
  eyeSide: document.getElementById('eyeSide')
};

/* State */
let running=false, faceMesh, faceMeshReady=false;
let roiEllipse=null; // {cx,cy,a,b,theta}
let lastGraySmall=null, greenSeries=[], sampleTimes=[];
let vesselSum=null, vesselCount=0, recording=false, recordStart=0, recTimer=null;
const MAX_SERIES=600;
const TH={minVarLap:80,maxMotion:0.08,maxGlare:0.10,minRoiFrac:0.02};

/* Helpers */
function logDebug(m,e=false){ dbg.textContent=m; dbg.className=e?'bad':'hint'; }
function selectedFacingMode(){ const r=[...document.querySelectorAll('input[name="cam"]')].find(x=>x.checked); return r? r.value:"environment"; }
function setClass(el, ok){ el.className='val '+(ok?'ok':'warn'); }
function setCanvasAspectFromVideo(){
  // Intrinsic bitmap size = video size; also inform CSS aspect-ratio to prevent squish
  overlay.width = video.videoWidth || 1280;
  overlay.height = video.videoHeight || 720;
  overlay.style.aspectRatio = `${overlay.width} / ${overlay.height}`;
  plot.width = Math.min(overlay.width, 900); plot.height = 110;
}
function toGraySmall(imageData,w,h,outW=160,outH=120){
  const gray=new Uint8ClampedArray(outW*outH), d=imageData.data;
  for(let j=0;j<outH;j++){ const y=Math.floor(j*h/outH);
    for(let i=0;i<outW;i++){ const x=Math.floor(i*w/outW); const idx=(y*w+x)*4;
      gray[j*outW+i]=(0.299*d[idx]+0.587*d[idx+1]+0.114*d[idx+2]);
    }
  } return {gray,outW,outH};
}
function varianceOfLaplacian(gray,w,h){
  const k=[0,1,0,1,-4,1,0,1,0]; let s=0,ss=0,n=0;
  for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
    let c=0,ki=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) c+=gray[(y+dy)*w+(x+dx)]*k[ki++];
    s+=c; ss+=c*c; n++;
  }
  if(n<2) return 0; const m=s/n; return ss/n - m*m;
}
function normalizedMADDiff(prev,curr){ let sa=0, sc=0, n=curr.length; for(let i=0;i<n;i++){ sa+=Math.abs(curr[i]-prev[i]); sc+=curr[i]; } const mi=Math.max(1,sc/n); return (sa/n)/mi; }
function pointInEllipse(x,y,el){ // (x',y') in rotated frame
  const ct=Math.cos(el.theta), st=Math.sin(el.theta);
  const dx=x-el.cx, dy=y-el.cy;
  const xp= ct*dx + st*dy, yp= -st*dx + ct*dy;
  return (xp*xp)/(el.a*el.a) + (yp*yp)/(el.b*el.b) <= 1.0;
}
function ellipseBBox(el){
  // Conservative bbox from axes (rotation-aware approximation)
  const ct=Math.cos(el.theta), st=Math.sin(el.theta);
  const wx=Math.hypot(el.a*ct, el.b*st);
  const wy=Math.hypot(el.a*st, el.b*ct);
  return {minX:el.cx-wx, maxX:el.cx+wx, minY:el.cy-wy, maxY:el.cy+wy};
}
function ellipseArea(el){ return Math.PI*el.a*el.b; }
function drawEllipse(el, stroke='rgba(255,230,0,0.95)', fill='rgba(255,230,0,0.15)'){
  if(!el) return;
  ctx.save();
  ctx.translate(el.cx, el.cy);
  ctx.rotate(el.theta);
  ctx.beginPath();
  ctx.ellipse(0,0, el.a, el.b, 0, 0, Math.PI*2);
  ctx.fillStyle=fill; ctx.strokeStyle=stroke; ctx.lineWidth=2;
  ctx.fill(); ctx.stroke();
  ctx.restore();
}
function drawFallbackBand(W,H){
  const y0=H*0.45, y1=y0+Math.max(8,H*0.03), x0=W*0.30, x1=W*0.70;
  ctx.save();
  ctx.setLineDash([8,6]); ctx.strokeStyle='rgba(0,220,255,0.95)'; ctx.lineWidth=2;
  ctx.strokeRect(x0,y0, x1-x0, y1-y0);
  ctx.restore();
}

/* Eye ellipse fit (single eye) */
function fitEyeEllipse(lm,W,H,right=true,scale=1.15){
  const eyeR=[33,7,163,144,145,153,154,155,133,173,157,158,159,160,161,246];
  const eyeL=[263,249,390,373,374,380,381,382,362,398,384,385,386,387,388,466];
  const ids = right? eyeR : eyeL;
  const pts = ids.map(i=>({x:lm[i].x*W, y:lm[i].y*H}));
  let cx=0, cy=0; for(const p of pts){ cx+=p.x; cy+=p.y; } cx/=pts.length; cy/=pts.length;
  let sxx=0,syy=0,sxy=0; for(const p of pts){ const dx=p.x-cx, dy=p.y-cy; sxx+=dx*dx; syy+=dy*dy; sxy+=dx*dy; }
  sxx/=pts.length; syy/=pts.length; sxy/=pts.length;
  const T=sxx+syy, D=sxx*syy - sxy*sxy, disc=Math.max(0, T*T/4 - D);
  const l1=T/2 + Math.sqrt(disc), l2=T/2 - Math.sqrt(disc);
  let vx1,vy1; if(Math.abs(sxy)>1e-6){ vx1=l1-syy; vy1=sxy; const n=Math.hypot(vx1,vy1)||1; vx1/=n; vy1/=n; } else { vx1=1; vy1=0; }
  let a=0,b=0; for(const p of pts){ const dx=p.x-cx, dy=p.y-cy; const t1=Math.abs(dx*vx1 + dy*vy1); const t2=Math.abs(-dx*vy1 + dy*vx1); if(t1>a) a=t1; if(t2>b) b=t2; }
  a*=scale; b*=scale;
  const theta=Math.atan2(vy1, vx1);
  return {cx,cy,a,b,theta};
}

/* MediaPipe */
let rightEye=true;
async function initFaceMesh(){
  faceMesh=new FaceMesh.FaceMesh({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
  faceMesh.setOptions({maxNumFaces:1,refineLandmarks:true,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
  faceMesh.onResults(onResults); faceMeshReady=true; logDebug('FaceMesh initialized.');
}

/* Camera */
async function startCamera(){
  try{
    const mode=selectedFacingMode();
    const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:mode},width:{ideal:1280},height:{ideal:720}},audio:false});
    video.srcObject=stream;
    await new Promise(res=> video.onloadedmetadata=()=>{ video.play(); setCanvasAspectFromVideo(); res(); });
  }catch(e){ logDebug('Camera error: '+e.message,true); throw e; }
}
function stopCamera(){ const s=video.srcObject; if(s) s.getTracks().forEach(t=>t.stop()); video.srcObject=null; }

/* Image ops (mask, vesselness, etc.) */
function conjunctivaMask(imageData, el){
  const {width:W,height:H,data}=imageData, bb=ellipseBBox(el);
  const x0=Math.max(0,Math.floor(bb.minX)), x1=Math.min(W-1,Math.ceil(bb.maxX));
  const y0=Math.max(0,Math.floor(bb.minY)), y1=Math.min(H-1,Math.ceil(bb.maxY));
  const outW=x1-x0+1, outH=y1-y0+1, mask=new Uint8Array(outW*outH);
  for(let y=y0;y<=y1;y++) for(let x=x0;x<=x1;x++){
    if(!pointInEllipse(x,y,el)) continue;
    const idx=(y*W+x)*4, r=data[idx], g=data[idx+1], b=data[idx+2];
    const V=Math.max(r,g,b), S= V? (V - Math.min(r,g,b))/V : 0;
    const isSclera=(V>240 && S<0.12), isLash=(V<35);
    const looksConj=(!isSclera && !isLash && r>=g && g>=b && S>=0.10 && S<=0.65 && V>=50 && V<=230);
    mask[(y-y0)*outW+(x-x0)] = looksConj?1:0;
  }
  return {mask,x0,y0,w:outW,h:outH};
}
function extractGreenConj(imageData, el, outW=240, outH=160){
  const {width:W,height:H,data}=imageData, bb=ellipseBBox(el);
  const x0=Math.max(0,Math.floor(bb.minX)), x1=Math.min(W-1,Math.ceil(bb.maxX));
  const y0=Math.max(0,Math.floor(bb.minY)), y1=Math.min(H-1,Math.ceil(bb.maxY));
  const roiW=x1-x0+1, roiH=y1-y0+1;
  const m=conjunctivaMask(imageData, el);
  const g=new Float32Array(outW*outH), mask=new Uint8Array(outW*outH);
  for(let j=0;j<outH;j++){ const sy=y0 + Math.floor(j*roiH/outH);
    for(let i=0;i<outW;i++){ const sx=x0 + Math.floor(i*roiW/outW); const idx=(sy*W+sx)*4;
      const mVal=(sx>=m.x0 && sx<m.x0+m.w && sy>=m.y0 && sy<m.y0+m.h) ? m.mask[(sy-m.y0)*m.w + (sx-m.x0)] : 0;
      mask[j*outW+i]=mVal?1:0; g[j*outW+i]=mVal? data[idx+1] : 0;
    }
  }
  return {g,w:outW,h:outH,mask};
}
function boxBlur(gray,w,h,r=3){ const tmp=new Float32Array(w*h), out=new Float32Array(w*h);
  for(let y=0;y<h;y++){ let sum=0; for(let x=0;x<w;x++){ const x0=Math.max(0,x-r), x1=Math.min(w-1,x+r);
    if(x===0){ sum=0; for(let i=x0;i<=x1;i++) sum+=gray[y*w+i]; } else { const prev=Math.max(0,x-1-r), next=Math.min(w-1,x+r); sum += gray[y*w+next]-gray[y*w+prev]; }
    tmp[y*w+x]=sum/(x1-x0+1); } }
  for(let x=0;x<w;x++){ let sum=0; for(let y=0;y<h;y++){ const y0=Math.max(0,y-r), y1=Math.min(h-1,y+r);
    if(y===0){ sum=0; for(let j=y0;j<=y1;j++) sum+=tmp[j*w+x]; } else { const prev=Math.max(0,y-1-r), next=Math.min(h-1,y+r); sum += tmp[next*w+x]-tmp[prev*w+x]; }
    out[y*w+x]=sum/(y1-y0+1); } } return out;
}
function vesselnessTopHatMasked(g,w,h,mask,blurR=3){
  const blurred=boxBlur(g,w,h,blurR); const raw=new Float32Array(w*h); let maxv=1e-6;
  for(let i=0;i<w*h;i++){ const v=mask[i]? Math.max(0, g[i]-blurred[i]) : 0; raw[i]=v; if(v>maxv) maxv=v; }
  const out=new Uint8ClampedArray(w*h); for(let i=0;i<w*h;i++) out[i]=Math.round(255*(raw[i]/maxv)); return out;
}

/* rPPG */
function plotSeries(series){
  const w=plot.width,h=plot.height; pctx.clearRect(0,0,w,h);
  if(series.length<2) return;
  const maxV=Math.max(...series), minV=Math.min(...series), rng=Math.max(1e-3,maxV-minV);
  pctx.strokeStyle="#7ef5d6"; pctx.lineWidth=2; pctx.beginPath();
  for(let i=0;i<series.length;i++){ const x=i*(w/(series.length-1)); const y=h-((series[i]-minV)/rng)*h; if(i===0) pctx.moveTo(x,y); else pctx.lineTo(x,y); }
  pctx.stroke();
}
function detrend(a,win=21){ const o=new Array(a.length).fill(0); for(let i=0;i<a.length;i++){ const A=Math.max(0,i-Math.floor(win/2)), B=Math.min(a.length-1,i+Math.floor(win/2)); let s=0; for(let k=A;k<=B;k++) s+=a[k]; o[i]=a[i]-s/(B-A+1);} return o; }
function hamming(N){ const w=new Array(N); for(let n=0;n<N;n++) w[n]=0.54-0.46*Math.cos(2*Math.PI*n/(N-1)); return w; }
function periodogramDFT(x,fs,freqs){ const N=x.length,P=new Array(freqs.length).fill(0); for(let k=0;k<freqs.length;k++){ const w=2*Math.PI*freqs[k]/fs; let re=0,im=0; for(let n=0;n<N;n++){ const ph=w*n; re+=x[n]*Math.cos(ph); im-=x[n]*Math.sin(ph);} P[k]=(re*re+im*im)/N;} return P; }
function analyzeRppg(times, vals){
  if(times.length<50) return {hr:null,acdc:null,snr:null};
  const dur=Math.max(0.1,times[times.length-1]-times[0]), fs=25;
  const M=Math.max(64,Math.min(256,Math.round(dur*fs))), t0=times[0], dt=dur/(M-1), xs=new Array(M);
  for(let i=0;i<M;i++){ const t=t0+i*dt; let j=0; while(j<times.length-1 && times[j]<t) j++; xs[i]=vals[Math.max(0,Math.min(times.length-1,j))]; }
  let x=detrend(xs,Math.round(fs*0.8)); const win=hamming(x.length); for(let i=0;i<x.length;i++) x[i]*=win[i];
  const mean=xs.reduce((a,b)=>a+b,0)/xs.length; const sd=Math.sqrt(x.reduce((a,b)=>a+b*b,0)/x.length);
  const acdc=mean>0? (sd/mean) : null;
  const fmin=0.8,fmax=3.5,step=0.02,freqs=[]; for(let f=fmin;f<=fmax;f+=step) freqs.push(f);
  const P=periodogramDFT(x,fs,freqs); let iMax=0; for(let i=1;i<P.length;i++) if(P[i]>P[iMax]) iMax=i;
  const fPeak=freqs[iMax], hr=Math.round(fPeak*60);
  const side=[]; for(let i=0;i<P.length;i++){ if(Math.abs(freqs[i]-fPeak)>0.06 && Math.abs(freqs[i]-fPeak)<0.5) side.push(P[i]); }
  const median= side.length? side.slice().sort((a,b)=>a-b)[Math.floor(side.length/2)] : 1e-6;
  const snr=(P[iMax]/Math.max(1e-6,median)).toFixed(2);
  return {hr, acdc: acdc? acdc.toFixed(4):null, snr};
}

/* Frame processing */
function onResults(res){
  if(!running) return;
  ctx.save();
  if(selectedFacingMode()==="user"){ ctx.translate(overlay.width,0); ctx.scale(-1,1); }
  ctx.drawImage(res.image,0,0,overlay.width,overlay.height);
  roiEllipse=null;
  if(res.multiFaceLandmarks && res.multiFaceLandmarks.length>0){
    const lm = res.multiFaceLandmarks[0];
    roiEllipse = fitEyeEllipse(lm, overlay.width, overlay.height, rightEye, 1.15);
    drawEllipse(roiEllipse);
  } else {
    drawFallbackBand(overlay.width, overlay.height);
  }
  ctx.restore();
  computeMetricsAndUpdateUI();
}

function computeMetricsAndUpdateUI(){
  const frame=ctx.getImageData(0,0,overlay.width,overlay.height);
  const {gray,outW,outH}=toGraySmall(frame,overlay.width,overlay.height);
  const varLap=varianceOfLaplacian(gray,outW,outH);
  const motion=lastGraySmall? normalizedMADDiff(lastGraySmall,gray):0; lastGraySmall=gray;

  let glare=1.0, rgb={r:0,g:0,b:0,n:0}, roiFrac=0;
  if(roiEllipse){
    // simple approximated coverage from bbox area
    const bb=ellipseBBox(roiEllipse);
    glare = glareFractionEllipse(frame, roiEllipse);
    rgb = meanRGBEllipse(frame, roiEllipse);
    roiFrac = ((bb.maxX-bb.minX)*(bb.maxY-bb.minY))/(overlay.width*overlay.height);
  }

  if(rgb.n>0){ pR.textContent=rgb.r.toFixed(0); pG.textContent=rgb.g.toFixed(0); pB.textContent=rgb.b.toFixed(0); pRG.textContent=(rgb.g>0?(rgb.r/rgb.g).toFixed(3):"—"); }

  const focusOk=varLap>=TH.minVarLap, motionOk=motion<=TH.maxMotion||!lastGraySmall, glareOk=glare<=TH.maxGlare, roiOk=roiFrac>=TH.minRoiFrac;
  mFocus.textContent=varLap.toFixed(0); setClass(mFocus,focusOk);
  mMotion.textContent=motion.toFixed(3); setClass(mMotion,motionOk);
  mGlare.textContent=(glare*100).toFixed(1)+"%"; setClass(mGlare,glareOk);
  mRoi.textContent=(roiFrac*100).toFixed(2)+"%"; setClass(mRoi,roiOk);
  mStatus.textContent= focusOk&&motionOk&&glareOk&&roiOk ? "PASS":"Adjust aim / light / stability"; setClass(mStatus, focusOk&&motionOk&&glareOk&&roiOk);

  const now=performance.now()/1000;
  if(rgb.n>0){
    greenSeries.push(rgb.g); sampleTimes.push(now);
    if(greenSeries.length>MAX_SERIES){ greenSeries.splice(0,greenSeries.length-MAX_SERIES); sampleTimes.splice(0,sampleTimes.length-MAX_SERIES); }
    plotSeries(greenSeries);
  }

  // Aiming crop (contain, no stretch)
  if(roiEllipse){
    const bb=ellipseBBox(roiEllipse);
    const padX=Math.max(8,(bb.maxX-bb.minX)*0.35), padY=Math.max(8,(bb.maxY-bb.minY)*0.8);
    const sx=Math.max(0,Math.floor(bb.minX-padX)), sy=Math.max(0,Math.floor(bb.minY-padY));
    const sw=Math.min(overlay.width-1,Math.ceil(bb.maxX+padX))-sx+1;
    const sh=Math.min(overlay.height-1,Math.ceil(bb.maxY+padY))-sy+1;
    const S=Math.min(aimCanvas.width/sw, aimCanvas.height/sh);
    const dw=sw*S, dh=sh*S, dx=(aimCanvas.width-dw)/2, dy=(aimCanvas.height-dh)/2;
    aimCtx.save(); aimCtx.clearRect(0,0,aimCanvas.width,aimCanvas.height);
    if(selectedFacingMode()==="user"){ aimCtx.translate(aimCanvas.width,0); aimCtx.scale(-1,1); }
    aimCtx.drawImage(overlay, sx,sy,sw,sh, dx,dy,dw,dh);
    aimCtx.restore();
  }
}

/* Mean/glare over ellipse (pixel-accurate) */
function meanRGBEllipse(imageData, el){
  const {width:W,height:H,data}=imageData, bb=ellipseBBox(el);
  const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(W-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(H-1,Math.ceil(bb.maxY));
  let sr=0,sg=0,sb=0,n=0;
  for(let y=minY;y<=maxY;y++) for(let x=minX;x<=maxX;x++){
    if(!pointInEllipse(x,y,el)) continue; const idx=(y*W+x)*4; sr+=data[idx]; sg+=data[idx+1]; sb+=data[idx+2]; n++;
  }
  return n? {r:sr/n,g:sg/n,b:sb/n,n} : {r:0,g:0,b:0,n:0};
}
function glareFractionEllipse(imageData, el){
  const {width:W,height:H,data}=imageData, bb=ellipseBBox(el);
  const minX=Math.max(0,Math.floor(bb.minX)), maxX=Math.min(W-1,Math.ceil(bb.maxX));
  const minY=Math.max(0,Math.floor(bb.minY)), maxY=Math.min(H-1,Math.ceil(bb.maxY));
  let cnt=0, br=0;
  for(let y=minY;y<=maxY;y++) for(let x=minX;x<=maxX;x++){
    if(!pointInEllipse(x,y,el)) continue; const idx=(y*W+x)*4;
    const Y=0.299*data[idx]+0.587*data[idx+1]+0.114*data[idx+2]; cnt++; if(Y>=245) br++;
  }
  return cnt? br/cnt : 1.0;
}

/* Loop */
async function loop(){
  if(!running) return;
  try{
    if(faceMeshReady){ await faceMesh.send({image:video}); }
    else{
      ctx.drawImage(video,0,0,overlay.width,overlay.height);
      drawFallbackBand(overlay.width,overlay.height);
      computeMetricsAndUpdateUI();
    }
  }catch(e){ logDebug('Loop error: '+e.message,true); }
  requestAnimationFrame(loop);
}

/* Record / Analyze */
function startRecording(){
  if(!running||recording) return;
  recording=true; recordStart=performance.now()/1000; ui.btnRecord.disabled=true;
  vesselSum=null; vesselCount=0; roiCtx.clearRect(0,0,roiCanvas.width,roiCanvas.height); vesselCtx.clearRect(0,0,vesselCanvas.width,vesselCanvas.height);
  let left=10.0; ui.recStatus.textContent=`Recording: ${left.toFixed(1)}s`;
  recTimer=setInterval(()=>{ left=Math.max(0,10-(performance.now()/1000-recordStart)); ui.recStatus.textContent=`Recording: ${left.toFixed(1)}s`; if(left<=0) stopRecordingAndAnalyze(); },100);
}
function cancelCountdown(){ if(recTimer){ clearInterval(recTimer); recTimer=null; } }
function stopRecordingAndAnalyze(){
  cancelCountdown(); recording=false; ui.recStatus.textContent="Analyzing…";
  const now=sampleTimes.length? sampleTimes[sampleTimes.length-1]:0;
  const idx=sampleTimes.findIndex(t=>t>=now-10);
  const times= idx>=0? sampleTimes.slice(idx): sampleTimes.slice();
  const vals = idx>=0? greenSeries.slice(idx): greenSeries.slice();
  const res=analyzeRppg(times,vals);
  rHR.textContent = res.hr? res.hr.toString():"—";
  rACDC.textContent = res.acdc? res.acdc:"—";
  rSNR.textContent = res.snr? res.snr:"—";

  if(roiEllipse){
    const frame=ctx.getImageData(0,0,overlay.width,overlay.height);
    const crop=extractGreenConj(frame,roiEllipse,roiCanvas.width,roiCanvas.height);
    const enh=vesselnessTopHatMasked(crop.g,crop.w,crop.h,crop.mask,3);
    // show masked ROI
    const roiImg=roiCtx.createImageData(crop.w,crop.h);
    for(let i=0;i<crop.w*crop.h;i++){ const v=crop.mask[i]? Math.round(crop.g[i]):0; roiImg.data[4*i+0]=v; roiImg.data[4*i+1]=v; roiImg.data[4*i+2]=v; roiImg.data[4*i+3]=255; }
    roiCtx.putImageData(roiImg,0,0);
    // show vesselness normalized
    let maxv=1; for(let i=0;i<enh.length;i++) if(enh[i]>maxv) maxv=enh[i];
    const vs=vesselCtx.createImageData(crop.w,crop.h);
    for(let i=0;i<enh.length;i++){ const vv=Math.round(255*enh[i]/maxv); vs.data[4*i+0]=vv*0.6; vs.data[4*i+1]=vv; vs.data[4*i+2]=vv*0.8; vs.data[4*i+3]=255; }
    vesselCtx.putImageData(vs,0,0);
  }
  ui.recStatus.textContent="Done"; ui.btnRecord.disabled=false;
}

/* Controls */
async function start(){
  ui.btnRecord.disabled=true; logDebug('Starting camera…');
  await startCamera(); setCanvasAspectFromVideo();
  logDebug('Initializing FaceMesh…'); try{ await initFaceMesh(); }catch(e){ logDebug('FaceMesh init error: '+e.message,true); }
  running=true; ui.recStatus.textContent='Live'; ui.btnRecord.disabled=false; loop();
}
function stop(){ running=false; stopCamera(); cancelCountdown(); ui.recStatus.textContent='Idle'; logDebug('Stopped.'); }

btnStart.onclick=async()=>{ if(!running) await start(); };
btnStop.onclick =()=> stop();
btnRecord.onclick=()=> startRecording();
ui.eyeSide.onchange = ()=>{ rightEye = ui.eyeSide.checked; };

/* Guards */
window.addEventListener('error',e=>logDebug('JS error: '+e.message,true));
if(!('mediaDevices' in navigator)) logDebug('Error: mediaDevices not available (use Safari over HTTPS).',true);
</script>
</body>
</html>
